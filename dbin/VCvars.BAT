:: setup Visual C/C++ command line build environment

:: Copyright (C) 2016-2020 ~ Roy Ivy III
:: License: GPLv3 (see https://opensource.org/licenses/GPL-3.0 @@ http://archive.is/id3YT)
:: * this software is provided for free, WITHOUT ANY EXPRESS OR IMPLIED WARRANTY (see the license for details)

:: ToDO: add support for `vswhere` for versions >= 2016 (VC15+); eg, `vswhere -property installationPath`

:: spell-checker:ignore (shell) nmake vcvarsall vcvarsx vswhere
:: spell-checker:ignore MAINT RETval RETvar bugfix fname popd pushd showall
:: spell-checker:ignore COMNTOOLS Cvars Cvarsall FSHARPINSTALLDIR HKLM LIBPATH MSVC MSVS Toolset VCINSTALLDIR VCVAR VCVARSARGS VCVERSION VCvars VCvarsall VSINSTALLDIR

@setLocal
@echo off
set "__dp0=%~dp0"
set "__ME=%~n0"
cd "%~dp0"
goto :_START

:$usage
echo %~nx0 [OPTIONS] [( VCVERSION ^| PATH ) [VCVARSARGS]]
echo:
echo OPTIONS
echo help/usage :: -?, -h, --help, --usage
echo echo       :: --echo
echo force      :: --force
echo prior      :: --or-prior, --prior
echo show-all   :: --list, --list-all, --show, --show-all
echo quiet      :: --quiet
echo:
echo VCVERSION = latest
echo             6 ^| 6-min ^| 7 ^| 7.1 ^| 8 ^| 9 ^| 10 ^| 11 ^| 12 ^| 14 ^| 15 ^| 16
echo             vc6 ^| vc6-min ^| vc7 ^| vc7.1 ^| vc8 ^| vc9 ^| vc10 ^| vc11 ^| vc12 ^| vc14 ^| vc15 ^| vc2017 ^| vc16 ^| vc2019
echo             vs6 ^| vs6-min ^| vs7 ^| vs7.1 ^| vs8 ^| vs9 ^| vs10 ^| vs11 ^| vs12 ^| vs14 ^| vs15 ^| vc2017 ^| vs16 ^| vc2019
echo             1998 ^| 2002 ^| 2003 ^| 2005 ^| 2010 ^| 2012 ^| 2013 ^| 2015 ^| 2016 ^| 2017 ^| 2019
echo             CL1200 ^| CL1300 ^| CL1310 ^| CL1400 ^| CL1500 ^| CL1600 ^| CL1700 ^| CL1800 ^| CL1900 ^| CL1911 ^| CL1922
echo:
echo NOTE: 1998 == CL1200 == VC6; 2002 == CL1300 == VC7; 2003 == CL1310 == VC7.1; 2005 == CL1400 == VC8
echo   ... 2008 == CL1500 == VC9; 2010 == CL1600 == VC10; 2012 == CL1700 == VC11; 2013 == CL1800 == VC12
echo   ... 2015 == CL1900 == VC14; 2016 == VC15; 2017 == CL1911 == VC2017; 2019 == CL1922 = VC2019
echo:
echo VCVARSARGS = x86 ^| x64 ^| amd64 ^| ia64 ^| x86_amd64 ^| x86_ia64
echo:
echo NOTE: PATH == path to directory containing VCvarsALL.bat, VCvars32.BAT, bin\VCvars32.BAT or path to the specific VCvars setup file
goto :EOF

:: NOTE: produces no ENV variable echo if there is an error

:: NOTE: VC9/2008 bug: vcvarsall incorrectly locates the batch files for x86_amd and x86_ia64.
::   ... WORKAROUND: After normal VC9 installation, copy the batch files vcvarsx86_amd64.bat and vcvarsx86_ia64.bat from the <VC9>\VC\bin directory into the <VC9>\VC\bin\x86_amd and <VC9>\VC\bin\x86_ia64 subdirectories, respectively.

:: TODO: deal with XP64, Vista64, 764
::      1) WOW6432node (eg, 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\6.0\Setup\Microsoft Visual C++' translates to  'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\6.0\Setup\Microsoft Visual C++')
::      2) installation to 'Program Files (x86)'

::NOT! == USE {PATH}
:: %VCVARS == [INPUT:optional]
::         # full path to Visual C/C++ environment setup batch file (usually either vcvarsall.bat or vcvars32.bat) [NO surrounding quotes]
::         # use VCVARS to skip lookup and specify desired C/C++ environment setup; generally used when multiple versions of VC are installed [or a version without registry entries installed in non-default location]

:: REFERENCES
:: VCVARSALL.bat (for 32- or 64-bit command-line builds): ref: [How to: Enable a 64-Bit Visual C++ Toolset at the Command Line] http://msdn.microsoft.com/en-us/library/x4d2c09s(VS.80).aspx @@ https://archive.is/J0MGG
:: VCVARS32.bat  (for 32-bit command-line builds): ref: [Setting the Path and Environment Variables for Command-Line Builds] http://msdn.microsoft.com/en-us/library/f2ccy3wt(VS.80).aspx @@ https://archive.is/tsGjd

:_START
call :$$echo_DEBUG [ %~nx0 ]

:: parse options
:parse_options
::
set "__help="
set "__echo="
set "__force="
set "__prior="
set "__showall="
set "__quiet="
::
set "arg="
set "args="
set "arg_list="
::
set args=%*
call :$transform_slash_question args &:: transform all isolated '/?' with '-?'; NOTE: ignores surrounding quoting; needed to avoid possible `call ... /? ...`, which fails
if NOT DEFINED args ( goto :parse_options_DONE )
call :$$create_list_with_NULLs arg_list %args%
call :$$echo_DEBUG arg_list = "%arg_list%"
::
if DEFINED arg_list call :$$first_list_match __help "-?;-h;--help;--usage" "%arg_list%"
if DEFINED __help ( call :$usage & exit /b 1 )
:: (sorted by estimated descending probability of occurrence)
if DEFINED arg_list call :$$first_list_match __showall "--list;--list-all;--show;--show-all" "%arg_list%"
if DEFINED __showall ( call :$$remove_from_list arg_list "%__showall%" "%arg_list%" )
if DEFINED arg_list call :$$first_list_match __force "--force" "%arg_list%"
if DEFINED __force ( call :$$remove_from_list arg_list "%__force%" "%arg_list%" )
if DEFINED arg_list call :$$first_list_match __echo "--echo" "%arg_list%"
if DEFINED __echo ( call :$$remove_from_list arg_list "%__echo%" "%arg_list%" )
if DEFINED arg_list call :$$first_list_match __prior "--or-prior;--prior" "%arg_list%"
if DEFINED __prior ( call :$$remove_from_list arg_list "%__prior%" "%arg_list%" )
if DEFINED arg_list call :$$first_list_match __quiet "--quiet" "%arg_list%"
if DEFINED __quiet ( call :$$remove_from_list arg_list "%__quiet%" "%arg_list%" )
call :$$list_to_items args "%arg_list%"
::
:parse_options_DONE

:: parse VCVAR argument
call :$$first_of arg "%arg_list%"

call :$$echo_DEBUG VCVARS_ARE_SET = "%VCVARS_ARE_SET%"
call :$$echo_DEBUG VCVARS = "%VCVARS%"
call :$$echo_DEBUG __echo = "%__echo%"
call :$$echo_DEBUG __force = "%__force%"
call :$$echo_DEBUG __prior = "%__prior%"
call :$$echo_DEBUG __showall = "%__showall%"
call :$$echo_DEBUG __quiet = "%__quiet%"
call :$$echo_DEBUG arg = "%arg%"
call :$$echo_DEBUG args = "%args%"
call :$$echo_DEBUG arg_list = "%arg_list%"

rem if DEFINED VCVARS_ARE_SET if NOT DEFINED __force ( goto :VCVARS_env )

:VCVARS_DO

:: KB ~ MSVC install paths
:: verified against Boost-Build [SVN Revision 52578 Fri Apr 24 17:45:34 MSD 2009]
:: ref: https://github.com/boostorg/build/search?utf8=%E2%9C%93&q=vcvarsall
::  ... https://github.com/boostorg/build/blob/ffcd9824851ef362d79d99f3de0d76055070ebbc/src/engine/guess_toolset.bat
::  ... https://github.com/boostorg/build/blob/5377199473f8d9858773ebb7daae69c772e6b3c5/src/engine/config_toolset.bat
::  ... https://github.com/boostorg/build/blob/ffcd9824851ef362d79d99f3de0d76055070ebbc/src/engine/vswhere_usability_wrapper.cmd
:: * names of registry keys containing the MSVC install path
:: v6.0 = "HKLM\\SOFTWARE\\Microsoft\\VisualStudio\\6.0\\Setup\\Microsoft Visual C++"
:: v7.0= "HKLM\\SOFTWARE\\Microsoft\\VisualStudio\\7.0\\Setup\\VC"
:: v7.1 = "HKLM\\SOFTWARE\\Microsoft\\VisualStudio\\7.1\\Setup\\VC"
:: v8.0 = "HKLM\\SOFTWARE\\Microsoft\\VisualStudio\\8.0\\Setup\\VC"
:: v8.0.express = "HKLM\\SOFTWARE\\Microsoft\\VCExpress\\8.0\\Setup\\VC"
:: v9.0 = "HKLM\\SOFTWARE\\Microsoft\\VisualStudio\\9.0\\Setup\\VC"
:: v9.0.express = "HKLM\\SOFTWARE\\Microsoft\\VCExpress\\9.0\\Setup\\VC"
::
:: NOTE: Visual C++ Toolkit 2003 (MSVC v7.1.toolkit) does not store its installation path in the registry...
::   ... * the environment variable 'VCToolkitInstallDir' and the default installation path are checked instead.

set "_check_single_version="
set "_csv_val=true"
if DEFINED __prior set "_csv_val="
if /i [%arg%]==[latest] ( call :$shift_args args %args% & goto :VCVARS_find )
::
if /i [%arg%]==[6]       ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_6 )
if /i [%arg%]==[vc6]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_6 )
if /i [%arg%]==[vs6]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_6 )
if /i [%arg%]==[1998]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_6 )
if /i [%arg%]==[CL1200]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_6 )
if /i [%arg%]==[6-min]   ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_6_min )
if /i [%arg%]==[vc6-min] ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_6_min )
if /i [%arg%]==[vs6-min] ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_6_min )
if /i [%arg%]==[7]       ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7 )
if /i [%arg%]==[vc7]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7 )
if /i [%arg%]==[vs7]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7 )
if /i [%arg%]==[2002]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7 )
if /i [%arg%]==[CL1300]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7 )
if /i [%arg%]==[7.1]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7_1 )
if /i [%arg%]==[vc7.1]   ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7_1 )
if /i [%arg%]==[vs7.1]   ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7_1 )
if /i [%arg%]==[2003]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7_1 )
if /i [%arg%]==[CL1310]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_7_1 )
if /i [%arg%]==[8]       ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_8 )
if /i [%arg%]==[vc8]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_8 )
if /i [%arg%]==[vs8]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_8 )
if /i [%arg%]==[2005]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_8 )
if /i [%arg%]==[CL1400]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_8 )
if /i [%arg%]==[9]       ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_9 )
if /i [%arg%]==[vc9]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_9 )
if /i [%arg%]==[vs9]     ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_9 )
if /i [%arg%]==[2008]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_9 )
if /i [%arg%]==[CL1500]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_9 )
if /i [%arg%]==[10]      ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_10 )
if /i [%arg%]==[vc10]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_10 )
if /i [%arg%]==[vs10]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_10 )
if /i [%arg%]==[2010]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_10 )
if /i [%arg%]==[CL1600]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_10 )
if /i [%arg%]==[11]      ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_11 )
if /i [%arg%]==[vc11]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_11 )
if /i [%arg%]==[vs11]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_11 )
if /i [%arg%]==[2012]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_11 )
if /i [%arg%]==[CL1700]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_11 )
if /i [%arg%]==[12]      ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_12 )
if /i [%arg%]==[vc12]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_12 )
if /i [%arg%]==[vs12]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_12 )
if /i [%arg%]==[2013]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_12 )
if /i [%arg%]==[CL1800]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_12 )
if /i [%arg%]==[14]      ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_14 )
if /i [%arg%]==[vc14]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_14 )
if /i [%arg%]==[vs14]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_14 )
if /i [%arg%]==[2015]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_14 )
if /i [%arg%]==[CL1900]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_14 )
if /i [%arg%]==[2016]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_15_0 )
if /i [%arg%]==[15]      ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_15 )
if /i [%arg%]==[vc15]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_15 )
if /i [%arg%]==[vs15]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_15 )
if /i [%arg%]==[2017]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_2017 )
if /i [%arg%]==[vc2017]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_2017 )
if /i [%arg%]==[vs2017]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_2017 )
if /i [%arg%]==[CL1911]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_2017 )
if /i [%arg%]==[16]      ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_16 )
if /i [%arg%]==[vc16]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_16 )
if /i [%arg%]==[vs16]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_16 )
if /i [%arg%]==[2019]    ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_2019 )
if /i [%arg%]==[vc2019]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_2019 )
if /i [%arg%]==[vs2019]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_2019 )
if /i [%arg%]==[CL1922]  ( set "_check_single_version=%_csv_val%" & call :$shift_args args %args% & goto :VCVARS_find_2019 )
::
if EXIST "%arg%" ( set "VCVARS=%arg%" & call :$shift_args args %args% & goto :VCVARS_file_find_DONE ) else (
    if DEFINED arg (
        echo ERR!: "%arg%" is not known VCVERSION or a PATH 1>&2
        call :$usage & exit /b -1
    ))

:: VCVARS_find
:VCVARS_find
:VCVARS_find_16
:VCVARS_find_2019
set "VCvars_version=VC2019" & set "VCvars_year=2019"
set "base_path=%ProgramFiles%\Microsoft Visual Studio\2019"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Enterprise\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Professional\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Community\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\BuildTools\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Preview\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Common7\IDE\VC"
set "base_path=%ProgramFiles(x86)%\Microsoft Visual Studio\2019"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Enterprise\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Professional\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Community\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\BuildTools\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Preview\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Common7\IDE\VC"
:VCVARS_find_2019_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"] & goto VCVARS_find_15 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_15
:VCVARS_find_15_3
:VCVARS_find_2017
set "VCvars_version=VC2017" & set "VCvars_year=2017"
set "base_path=%ProgramFiles%\Microsoft Visual Studio\2017"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Enterprise\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Professional\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Community\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\BuildTools\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Preview\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Common7\IDE\VC"
set "base_path=%ProgramFiles(x86)%\Microsoft Visual Studio\2017"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Enterprise\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Professional\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Community\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\BuildTools\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Preview\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Common7\IDE\VC"
:VCVARS_find_2017_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"] & goto VCVARS_find_15_0 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if DEFINED VCVARS goto :VCVARS_find_DONE
:VCVARS_find_15_0
set "VCvars_version=vc15" & set "VCvars_year=2016"
set "base_path=%ProgramFiles%\Microsoft Visual Studio\VS15"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Enterprise\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Professional\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Community\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\BuildTools\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Common7\IDE\VC"
set "base_path=%ProgramFiles%\Microsoft Visual Studio\VS15Preview"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Enterprise\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Professional\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Community\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\BuildTools\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Common7\IDE\VC"
set "base_path=%ProgramFiles(x86)%\Microsoft Visual Studio\VS15"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Enterprise\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Professional\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Community\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\BuildTools\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Common7\IDE\VC"
set "base_path=%ProgramFiles(x86)%\Microsoft Visual Studio\VS15Preview"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Enterprise\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Professional\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Community\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\BuildTools\VC\Auxiliary\Build"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%base_path%\Common7\IDE\VC"
:VCVARS_find_15_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"] & goto VCVARS_find_14 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_14
set "VCvars_version=vc14" & set "VCVARS_year=2015"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version%; VCVARS=%VCVARS% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS140COMNTOOLS%\..\..\VC"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_12 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\14.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_12 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\14.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
        SET "VC_VERSION=14"
    )
:VCVARS_find_14_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_12 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VCExpress\14.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_12 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VCExpress\14.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_14e_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_12 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_12
set "VCvars_version=vc12" & set "VCVARS_year=2013"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version%; VCVARS=%VCVARS% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS120COMNTOOLS%\..\..\VC"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_11 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\12.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_11 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\12.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
        SET "VC_VERSION=12"
    )
:VCVARS_find_12_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_11 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VCExpress\12.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_11 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VCExpress\12.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_12e_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_11 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_11
set "VCvars_version=vc11" & set "VCVARS_year=2012"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version%; VCVARS=%VCVARS% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS110COMNTOOLS%\..\..\VC"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_10 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\11.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_10 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\11.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
        SET "VC_VERSION=11"
    )
:VCVARS_find_11_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_10 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VCExpress\11.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_10 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VCExpress\11.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_11e_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_10 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_10
set "VCvars_version=vc10" & set "VCvars_year=2010"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version%; VCVARS=%VCVARS% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS100COMNTOOLS%\..\..\VC"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_9 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_9 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\10.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
        SET "VC_VERSION=10"
    )
:VCVARS_find_10_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_9 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VCExpress\10.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_9 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VCExpress\10.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_10e_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_9 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_9
set "VCvars_version=vc9" & set "VCvars_year=2008"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version%; VCVARS=%VCVARS% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS90COMNTOOLS%\..\..\VC"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_8 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_8 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\9.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
        SET "VC_VERSION=9"
    )
:VCVARS_find_9_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_8 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VCExpress\9.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_8 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VCExpress\9.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_9e_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_8 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_8
set "VCvars_version=vc8" & set "VCvars_year=2005"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version%; VCVARS=%VCVARS% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS80COMNTOOLS%\..\..\VC"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles%\Microsoft Visual Studio 8\VC"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles(x86)%\Microsoft Visual Studio 8\VC"
call :$$echo_DEBUG [ VCVARS=%VCVARS%]
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_7_1 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\8.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_7_1 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\8.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_8_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_7_1 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VCExpress\8.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_7_1 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VCExpress\8.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_8e_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_7_1 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_7_1
set "VCvars_version=vc7.1" & set "VCvars_year=2003"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version%; VCVARS=%VCVARS% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS71COMNTOOLS%\..\..\VC"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_7 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\7.1\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_7 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\7.1\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_7_1_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version% PATHs]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VCToolkitInstallDir%"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles%\Microsoft Visual C++ Toolkit 2003"
call :$$echo_DEBUG [ VCVARS=%VCVARS%]
:VCVARS_find_7_1t_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_7 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_7
set "VCvars_version=vc7" & set "VCvars_year=2002"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version% 7.1t; VCVARS=%VCVARS% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS70COMNTOOLS%\..\..\VC"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_6 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\7.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_6 )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\7.0\Setup\VC" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
:VCVARS_find_7_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_6 )
if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_6
set "VCvars_version=vc6" & set "VCvars_year=1998"
call :$$echo_DEBUG [ testing VCVARS_version=%VCVARS_version% ]
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%VS60COMNTOOLS%\..\..\VC"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_6_DONE)
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\6.0\Setup\Microsoft Visual C++" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_6_DONE)
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
set _cmd="%SystemRoot%\system32\reg" query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\6.0\Setup\Microsoft Visual C++" /v "ProductDir" 2^> nul
:: CMD needs surrounding quotes
set _cmd="%_cmd%"
for /f "tokens=1,2*" %%A in (
    '%_cmd%'
    ) do (
::      echo set "VCVARS=%%C"
        SET "VCVARS=%%C"
    )
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"]& goto VCVARS_find_6_DONE)
if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:: ALTERNATE/minimal installation of Visual C++ 6 (VC6min)
:: search common installation paths: %LocalAppData%\scoop\apps\msvc\6\VC6; %LocalAppData%\MSVC-portable\VC6; %SystemDrive%\VC6; %ProgramFiles%\VC6; %ProgramFiles%\VisualC; %ProgramFiles%\VisualC6
:VCVARS_find_6_min
set "VCvars_version=vc6" & set "VCvars_year=1998"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%LocalAppData%\scoop\apps\msvc\6.0\VC\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%LocalAppData%\MSVC-portable\VC6\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%LocalAppData%\MSVC-portable\VC\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%SystemDrive%\VC6\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles%\VC6\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles%\VisualC\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles%\VisualC6\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles(x86)%\VC6\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles(x86)%\VisualC\vcvars32.BAT"
if NOT DEFINED VCVARS call :$VARS_file_path VCVARS "%ProgramFiles(x86)%\VisualC6\vcvars32.BAT"
:VCVARS_find_6_min_DONE
:VCVARS_find_6_DONE
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED __showall if DEFINED VCVARS ( set "VCVARS=" & echo %VCvars_version% [%VCvars_year%; "%VCVARS%"])
:: if DEFINED _check_single_version ( goto :VCVARS_find_DONE )
:: if NOT "%VCVARS%"=="" goto :VCVARS_find_DONE
:VCVARS_find_DONE

if DEFINED __showall exit /b 0
if NOT DEFINED VCVARS (
    echo %__ME%: ERROR: cannot find location of Visual C installation
    exit /b -1
    )

:VCVARS_file_find
if DEFINED VCVARS call :$VARS_file_path VCVARS "%VCVARS%"
if DEFINED VCVARS ( goto :VCVARS_file_find_DONE )
echo %__ME%: ERROR: cannot find vcvarsall.bat, vcvars32.bat, or bin\vcvars32.bat [in "%VCVARS%"]
exit /b -1
:VCVARS_file_find_DONE

if NOT DEFINED VCVARS (
    echo %__ME%: ERROR: cannot find location of Visual C installation
    exit /b -1
    )
if NOT EXIST "%VCVARS%" (
    echo %__ME%: ERROR: "%VCVARS%" does not exist
    exit /b -1
    )

:VCVARS_env
if NOT DEFINED VCvars_version (
    if NOT "%VCVARS_ARE_SET%" == "1" (
        set VCvars_version=%VCVARS_ARE_SET%
    ) else set VCvars_version=VC?
)
if NOT DEFINED VCVARS ( goto :VCVARS_no_call )
:: skip the call if VCVARS_ARE_SET unless FORCE
if NOT DEFINED VCVARS_ARE_SET ( goto :VCVARS_call )
if DEFINED __force ( goto :VCVARS_call )
:VCVARS_no_call
call :$$echo_DEBUG no VCVARS call
( endLocal
    set __VCVARS_message=no changes
    set __VCvars_ME=%__ME%
    set __VCvars_echo=%__echo%
    set __VCvars_quiet=%__quiet%
    set VCvars_version=%VCvars_version%
    set VCvars_year=%VCvars_year%
    )
goto :VCVARS_env_DONE

:VCVARS_call
:: bugfix for VC14 bug (`rc` missing / not on PATH)
:: ref: https://stackoverflow.com/questions/14372706/visual-studio-cant-build-due-to-rc-exe/46166632#46166632 @@ https://archive.is/6HPIG#19.25%
:: ref: https://stackoverflow.com/questions/43847542/rc-exe-no-longer-found-in-vs-2015-command-prompt/45319119 @@ https://archive.is/GuODI
if /i "%VCVARS_version%"=="VC14" if NOT DEFINED args ( set "args=x86 8.1" )
if /i "%VCVARS_version%"=="VC14" if /i "%args%"=="x86" ( set "args=%args% 8.1" )
if /i "%VCVARS_version%"=="VC14" if /i "%args%"=="x64" ( set "args=%args% 8.1" )
if /i "%VCVARS_version%"=="VC14" if /i "%args%"=="amd64" ( set "args=%args% 8.1" )
if /i "%VCVARS_version%"=="VC14" if /i "%args%"=="ia64" ( set "args=%args% 8.1" )
if /i "%VCVARS_version%"=="VC14" if /i "%args%"=="x86_amd64" ( set "args=%args% 8.1" )
if /i "%VCVARS_version%"=="VC14" if /i "%args%"=="x86_ia64" ( set "args=%args% 8.1" )
::

if NOT DEFINED args ( set "args=x86" )
call :$$echo_DEBUG call "%VCVARS%" %args%
( endLocal
    pushd .
    call "%VCVARS%" %args% >NUL
    popd
    set __VCVARS_message=setup complete
    set __VCvars_ME=%__ME%
    set __VCvars_echo=%__echo%
    set __VCvars_quiet=%__quiet%
    set VCvars_version=%VCvars_version%
    set VCvars_year=%VCvars_year%
    )

:: increase compatibility between VC6 and later version environment variables
if NOT DEFINED MSVCDir          (set "MSVCDir=%VCINSTALLDIR%")
if NOT DEFINED VCINSTALLDIR     (set "VCINSTALLDIR=%MSVCDir%")

:VCVARS_env_DONE
( setLocal
    set __ME=%__VCvars_ME%
    call :$$echo_DEBUG MAKE = "%MAKE%"
    call :$$echo_DEBUG MSVCDir = "%MSVCDir%"
    call :$$echo_DEBUG VCINSTALLDIR = "%VCINSTALLDIR%"
endLocal
)

:: check setup for correctness
set "__CL_exe="
call :_path_of_file_in_PATH __CL_exe cl ".exe"
if NOT DEFINED __CL_exe (
    echo %__VCvars_ME%: ERROR: unable to find `cl.exe` [VCINSTALLDIR="%VCINSTALLDIR%"]
    set __VCVARS_message=setup completed [but with ERRORS]
    set __VCvars_exit=-1
    goto :DONE
    )
:: check setup for correctness
set "__RC_exe="
call :_path_of_file_in_PATH __RC_exe rc ".exe"
if NOT DEFINED __RC_exe (
    echo %__VCvars_ME%: ERROR: unable to find `rc.exe` [VCINSTALLDIR="%VCINSTALLDIR%"]
    set __VCVARS_message=setup completed [but with ERRORS]
    set __VCvars_exit=-1
    goto :DONE
    )
:: find `nmake` [using default PATHEXT order {ref: https://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/ntcmds_shelloverview.mspx @@ https://archive.is/BzbHM }]
set "__NMAKE_exe="
call :_path_of_file_in_PATH __NMAKE_exe nmake ".com;.exe;.bat;.cmd"
if NOT DEFINED __NMAKE_exe (
    echo %__VCvars_ME%: ERROR: unable to find `nmake` [VCINSTALLDIR="%VCINSTALLDIR%"]
    set __VCVARS_message=setup completed [but with ERRORS]
    set __VCvars_exit=-1
    goto :DONE
    )
set "__NMAKE_exe="

:: set confirmation environment variable
if %ERRORLEVEL% EQU 0 (
    set VCVARS_ARE_SET=%VCvars_version%
    if NOT DEFINED VCVARS_ARE_SET (set VCVARS_ARE_SET=1)
    )

:: ECHO
if NOT defined __VCvars_echo ( goto :ECHO_DONE )
:: each version of MSVS changes the variables that are setup, so just echo ALL variables
:: [2012-03-15] MSVS 10: vars == DevEnvDir; Framework35Version; FrameworkDir; FrameworkDIR32; FrameworkVersion; FrameworkVersion32; FSHARPINSTALLDIR; INCLUDE; LIB; LIBPATH; MAKE; MSVCDir; PATH; VCINSTALLDIR; VCVARS_ARE_SET; VSINSTALLDIR; WindowsSdkDir;
( setLocal
set "__VCvars_ME="
set "__VCvars_echo="
set "__VCvars_exit="
set "__VCVARS_message="
set
endLocal
)
:ECHO_DONE

:DONE
::# MAINT:* [2016-02] current algorithm works for `cl` v12 (as "1200"; aka VS6/VC6/1998) through v19 (as "1900" and "1911", aka VS14/VC14/2015 and 2017); dependent on output of `cl`, which *has* changed between versions
for /f "tokens=6-10" %%g in ('cl 2^>^&1 ^| findstr /I /C:"Version"') do (
    if /I "%%g"=="Version" (
        set VCvars_CL_version=%%h
        set VCvars_CL_target_cpu=%%j
    ) else if /I "%%h"=="Version" (
        set VCvars_CL_version=%%i
        set VCvars_CL_target_cpu=%%k
    ) else (
        set VCvars_CL_version=19.0+
        set VCvars_CL_target_cpu=?
    )
    )
if /I "%VCvars_CL_target_cpu%"=="80x86" ( set "VCvars_CL_target_cpu=x86") &:: standardize
for /f "tokens=6-10 delims=. " %%g in ('cl 2^>^&1 ^| findstr /I /C:"Version"') do (
    if /I "%%g"=="Version" (
        set VCvars_CL_VER=%%h%%i
    ) else if /I "%%h"=="Version" (
        set VCvars_CL_VER=%%i%%j
    ) else set VCvars_CL_VER=19.11+
    )
if NOT DEFINED __VCvars_quiet ( echo %__VCvars_ME%: %__VCVARS_message% ^(%VCvars_version%; cl-%VCvars_CL_version%/%VCvars_CL_target_cpu%^) )
if NOT DEFINED __VCvars_exit (set __VCvars_exit=0)
set "__VCvars_ME="
set "__VCvars_echo="
set "__VCvars_quiet="
set "__VCVARS_version="
set "__VCVARS_message="
set "__VCvars_CL_version="
set "__VCvars_exit=" & goto _undefined_ 2>NUL || "%COMSPEC%" /d/c exit %__VCvars_exit%

goto :EOF
::
:: LOCAL FUNCTIONS
::

::
:$VARS_file_path ( ref_RETURN PATH )
:: return path to any VCvarsall.BAT (preferred) or VCvars32.BAT associated with PATH
::
setLocal
set "__DEBUG_KEY=1"
set "__MEfn=VARS_file_path"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
REM set "_RETval="
set "_RETvar=%~1"
set "_path=%~2"
set "fname=%~nx2"
::
if NOT EXIST "%_path%" ( set "_path=" & goto :$VARS_file_path_DONE )
if /I "%fname%"=="vcvarsall.BAT" ( goto :$VARS_file_path_DONE )
if /I "%fname%"=="vcvars32.BAT" ( goto :$VARS_file_path_DONE )
call :$is_dir is_dir "%_path%"
if NOT DEFINED is_dir ( set "_path=" & goto :$VARS_file_path_DONE )
if EXIST "%_path%\vcvarsall.BAT" (
    set "_path=%_path%\vcvarsall.BAT"
    goto :$VARS_file_path_DONE
    )
if EXIST "%_path%\vcvars32.BAT" (
    set "_path=%_path%\vcvars32.BAT"
    goto :$VARS_file_path_DONE
    )
if EXIST "%_path%\bin\vcvars32.BAT" (
    set "_path=%_path%\bin\vcvars32.BAT"
    goto :$VARS_file_path_DONE
    )
set "_path="
rem echo %__ME%: ERROR: cannot find vcvarsall.bat, vcvars32.bat, or bin\vcvars32.bat [in "%VCVARS%"]
rem exit /b -1
:$VARS_file_path_DONE
if DEFINED _path call :$FQ_name_of _path "%_path%"
:$VARS_file_path_RETURN
REM call :_echo_DEBUG_KEY [ %__MEfn% :: _RETvar=%_RETvar% ]
REM call :_echo_DEBUG_KEY [ %__MEfn% :: _path=%_path% ]
endLocal & set %_RETvar%^=%_path%
goto :EOF
::

::
:$shift_args ( ref_RETURN ARGS )
::
setLocal
set "_RETval="
set "_RETvar=%~1"
::
set "args="
set "arg_list="
set line=%*
if NOT DEFINED line ( goto :$shift_args_DONE )
call :$$create_list_with_NULLs arg_list %*
call :$$remove_first arg_list "%arg_list%"
call :$$remove_first arg_list "%arg_list%"
if NOT DEFINED arg_list ( goto :$shift_args_DONE )
call :$$list_to_items _RETval "%arg_list%"
:$shift_args_DONE
:$shift_args_RETURN
endLocal & set %_RETVAR%^=%_RETVAL%
goto :EOF
::

::
:$transform_slash_question ( ref_VARNAME )
::
setLocal enableDelayedExpansion
set _RETval=!%1!
set "_RETvar=%~1"
::
if NOT DEFINED _RETval ( goto :$transform_slash_question_DONE )
if "!_RETval!"=="/?" ( set "_RETval=-?" )
:$transform_slash_question_loop
set t=%_RETval: /? = -? %
if NOT "!t!"=="!_RETval!" (
    set _RETval=%t%
    goto :$transform_slash_question_loop
)
:$transform_slash_question_loop_DONE
set t=%_RETval:~0,3%
if "!t!"=="/? " (
    set _RETval=-? %_RETval:~3%
)
set t=%_RETval:~-3%
if "!t!"==" /?" (
    set args=%_RETval:~0,-3% -?
)
:$transform_slash_question_DONE
:$transform_slash_question_RETURN
endLocal & set %_RETVAR%^=%_RETVAL%
goto :EOF
::

@::::
@:: FUNCTIONS (library:rev81)
@call %*
@goto :EOF
::

:: Copyright (C) 2011-2020 ~ Roy Ivy III
:: License: GPLv3 (see https://opensource.org/licenses/GPL-3.0 @@ http://archive.is/id3YT)
:: * this software is provided for free, WITHOUT ANY EXPRESS OR IMPLIED WARRANTY (see the license for details)

:: spell-checker:ignore (common-ENV-vars) COMSPEC ERRORLEVEL SYSTEMDRIVE SYSTEMROOT CMDCMDLINE
:: spell-checker:ignore (common-shell-commands) gccvars TCMD findstr loadbtm readlink realpath makecab readsymlink wmic systeminfo whoami
:: spell-checker:ignore (names) dbenham dbenham's jeb jeb's rivy
:: spell-checker:ignore (vars/names) Einitialize Tval Tvar preinitialize preinitialization VARNAME subshell fullpath PATHEXT PATHLIST PATHLISTs tempfile CMDVARIABLES COMSPECNAME PARSETYPE rtrim dpnx NTFS shortname fullname filetime ampm filedate readonly ITEMNAME DIRCMD EXTENSIONLIST EXTS CURRENTDRIVE ltrim dequote dequoted delims WBEM autorun osarchitecture symlink symlinks NONUNC parens MEFN undefines dnpx subshells devmode HKEY echo'd PRIV nocase pathnames
:: spell-checker:ignore prepend prepended canonicalized

:: NOTE: ToDO: as a notation signal, function labels are annotated with $; library functions will be annotated with $$ or $_ to avoid clashes with other SUBs/functions

:: NOTE: ToDO: add noLF versions to all $$echo... functions

:: NOTE: ToDO: add ability to store/use/return double-quotes and semicolons (? using character replacements)
:: #.... use ref: https://sbjh.wordpress.com/2013/02/08/generate-any-control-character @@ https://archive.is/QYqgh

:: NOTE: fix bug working with ampersand (&) characters; any problems with redirection characters, etc?

:: NOTE: for use with TCC, _MUST_ have TCMD.INI "CMDVariables=Yes"; this, plus all the WAD ("works as designed") bugs & the interminably slow execution of large batch files makes the case for completely removing TCC compatibility

:: NOTE: BAT/CMD script files require PC (CRLF) line endings for correct function; ASCII/UTF-8 encoding should also be used

:: NOTES
:: DEFINITIONS
:: ITEMs are character strings which may contain no internal double quotes (and no characters outside the usual non-graphical, printable set [ ord(ch) > 31, ord(ch) < 128 ]
:: LISTs are a ';' separated list of ITEMs
:: SETs or PATHLISTs are LISTs which contain unique individual ITEMs (and don't accept duplicate additions)
:: PATHLISTs don't accept NULL ITEM additions
:: PATHLISTs normalize all added ITEMs as PATHs (which removes any trailing backslashes [DOS/Win path dividers])
:: BOOLEAN values are defined as FALSE == NULL, TRUE == any non-NULL value (generally "1" or "true", but can be any non-NULL, including "0")
:: :: this makes testing for truth easy... if DEFINED foo ( echo true ) else ( echo false )
::
:: LISTs may contain NULL values, and are all defined as "" in the special case of containing a single NULL value
:: NULL valued ITEMs within LISTs may be either encoded as either "" or NULL, but will be returned as NULL when using functions returning individual elements within LISTs
::
:: NOTE: Don't use '(set %RETvar%=%RETval%)' for return values as internal close parenthesis in RETval will cause errors. Use 'set "%RETvar%=%RETval%"' instead.
:: NOTE: ... if RETval may contain double quotes, must use 'endLocal & set %RETvar%=%RETval%', as surrounding aa double quote with double quotes won't work.

:: ToDO: add new function "get_output( REF_VARNAME COMMAND )" that runs COMMAND & stores the last line output into VARNAME (initial plan is to use a temporary file)

:: ToDO: ( endLocal ... ) block and variations to bypass setLocal/endLocal walls
:: ToDO: BLOG needed parens for ifs in end ( endLocal ... ) block o/w only 1st if is evaluated

:: ref: Use of $ as subroutine sigil @@ http://www.webcitation.org/5z4F3V9yk @ 2011-05-30.0754

:: ToDO: rethink returning values (using jeb's technique @ http://www.dostips.com/forum/viewtopic.php?p=6930#p6930 @@ http://www.webcitation.org/6ADfeDSrJ)

:: ToDO: rethink PATH functions in reference to the following notes:
::     : [How-TO check if directory is within PATH] "http://stackoverflow.com/questions/141344/how-to-check-if-directory-exists-in-path/8046515#8046515"
::     : [How-TO split PATH on ';' - initial correct answer] http://stackoverflow.com/questions/5471556/pretty-print-windows-path-variable-how-to-split-on-in-cmd-shell/5472168#5472168
::     : [How-TO split PATH on ';' - slightly improved answer] http://stackoverflow.com/a/7940444/43774

:: ToDO: look at [DOS Function Collection] http://www.dostips.com/DtCodeFunctions.php @@ http://www.webcitation.org/6ADg2siao

:: ToDO: look at [Date Math] http://www.robvanderwoude.com/datetimentmath.php @@ http://www.webcitation.org/6Ei47MYcp AND http://www.powercram.com/2010/07/get-yesterdays-date-in-ms-dos-batch.html @@ http://www.webcitation.org/6ADgoDmWV

:: DONE: add is_dir [see http://stackoverflow.com/questions/8909355/how-to-check-if-target-of-path-is-a-directory]

:: ToDO: rethink PREinitialize ... currently, doesn't work as portrayed; %0 %* is NOT the main script and it's arguments; so, the script can't be re-run as written; additionally, environment variables and path changes are lost when returning from the subshell, so it's not correct; calling the script directly doesn't change the parse/comspec misalignment
::          :: possible, changing comspec and recalling directly after PREinitialize might work
::      NOTE: the only culprit known right now is Perl with a TCC shell and an empty Perl5SHELL environment variable
::          :: this is one Perl fix: `perl -e "if (not defined $ENV{PERL5SHELL}) {$ENV{COMSPEC}=q{c:\windows\system32\cmd.exe}}; system(q{gccvars perl});"`

:: ToDO: ?? change API function names to use sigil sign ($)?

:: NOTE: Use DEFINED and NOT DEFINED instead of comparison of vars to "" when possible to avoid quoting issues as much as possible
:: NOTE: "%_RETvar%" == "" comparison @ function RETURN is necessary because of endLocal which undefines _RETvar after the %% instantiation

:: DONE::ToDO: update API changes :: _echo_no_LF => _echo_noLF ; _path_of_first => _path_of_file
:: ToDO: !! change path_of_item_in_pathlist to either NOTE NULL item will be found in first existing path OR return NULL
:: ToDO: !! copy updated library to all other BATs
:: ToDO: update library documentation with a list of functions & short, one line explanations as a summary section

:: ref: [CMD Syntax: Escape characters, delimiters, & quotes] http://ss64.com/nt/syntax-esc.html @@ http://archive.is/V92JZ
:: ref: [CMD parsing (at command line & at batch file level)] http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/4095133#4095133

:: ref: [dbenham HOME - CharLib.BAT] https://sites.google.com/site/dbenhamfiles/home @@ http://archive.is/8KAbT
:: ref: [BUG SOLVED! - Return any string across endLocal boundary; using %%2 ... in FOR] http://www.dostips.com/forum/viewtopic.php?f=3&t=1839 @@ http://archive.is/0QuYk

::
::
:#exit_with_ERRORLEVEL
:: exits with %ERRORLEVEL%, *correctly* setting both ERRORLEVEL and the process exit code (no matter how called)
:: NOTE: NOT a subroutine; ONLY execute this code directly by using GOTO
:: VARS: GLOBAL::ERRORLEVEL; must be pinned [via "set ERRORLEVEL=..."] prior to execution; INT == batch + process exit value
:: example: `if NOT "%ERRORLEVEL%" == "0" ( set ERRORLEVEL=%ERRORLEVEL% & goto #exit_with_ERRORLEVEL )`
:: ref: <http://stackoverflow.com/questions/4864670/how-to-exit-a-cmd-file-and-the-shell-at-the-same-time#4876381>[`@`](https://archive.is/X2mkm#29%)
:: ref: @dbenham's comment on the answer <http://stackoverflow.com/questions/23327304/my-goto-redirect-is-not-working-but-works-with-echo/23327977#23327977>[`@`](http://archive.is/6CgpF#39.25%)
::
:: release pinned ERRORLEVEL & shift into command line context & die/exit (setting both ERRORLEVEL + process exit code)
::
:: ! bug: blocks parent process reset of window title, leading to ever-expanding window titles; so, reset to name of "%COMSPEC%" as a default
:: * note: for correct operation, `setLocal` cannot be used; so, as we are within the parent variable space, be careful to avoid environment variable overwrites
REM set "ERRORLEVEL=" & goto _undefined_label_ 2>NUL || "%COMSPEC%" /d /c exit %ERRORLEVEL%
call :#exit__title __exit_title "%COMSPEC%"
set "__exit_title=" && title %__exit_title% && set "ERRORLEVEL=" & goto _undefined_ 2>NUL || "%COMSPEC%" /d/c "exit %ERRORLEVEL%"
::echo "NEVER EXECUTE" code has been executed!!! 1>&2
goto :EOF &:: should NEVER be executed
::
:#exit__title ( ref_RETURN PATH )
:: RETURN == name of PATH
setLocal
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( set "_RETval=cmd" & goto :#exit__title_RETURN )
set "_RETval=%~n2"
:#exit__title_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:__exec_self_as_BTM
:: NOTE: should NOT be called as a subroutine; ONLY use directly, with a guarded GOTO (eg, "if 1.0 == 01 if /i "%~x0" neq ".BTM" goto :__exec_self_as_BTM")
:: VARS: GLOBAL::__exec_self_as_BTM_localize; must be set prior to execution; BOOLEAN == is current script localized within setLocal/endLocal block?; required to set up balanced setLocal/endLocal blocks within newly incarnated BTM
:: VARS: GLOBAL::__ME, __ME_dir, __ME_fullpath; REQUIRED; these are passed on through to the new BTM script as pointers to the context of the original script
:: NOTE: Prior failed attempts at TCC speedup:
:: * @if 1.0 == 1 ( loadbtm on 1> nul 2> nul & cd . ) &:: only works for TCC (not TCC/LE) and DOESN'T work well at all, timing seems just as slow!! (Maybe this is because of the call's to subroutines?)
:: * @if 1.0 == 1 ( option //UpdateTitle=No ) &:: ToDO: TEST by timing -- speeds up TCC execution by disabling window title updates? -- NO, initial testing shows no differences
if NOT 01 == 1.0 ( echo %__ME%:__exec_self_as_BTM: ERROR: Console interpreter is NOT TCC/4NT; unable to execute script as BTM 1>&2 & @echo %__ME_echo% & @exit /B -1 )
if NOT defined __ME ( echo %__ME%:__exec_self_as_BTM: ERROR: __ME must be defined prior to call; unable to execute script as BTM 1>&2 & @echo %__ME_echo% & @exit /B -1 )
if NOT defined __ME_dir ( echo %__ME%:__exec_self_as_BTM: ERROR: __ME_dir must be defined prior to call; unable to execute script as BTM 1>&2 & @echo %__ME_echo% & @exit /B -1 )
if NOT defined __ME_fullpath ( echo %__ME%:__exec_self_as_BTM: ERROR: __ME_fullpath must be defined prior to call; unable to execute script as BTM 1>&2 & @echo %__ME_echo% & @exit /B -1 )
call :_tempfile __exec_self_as_BTM_TEMPFILE "%__ME_fullpath%" .BTM
if NOT exist "%__exec_self_as_BTM_TEMPFILE%" ( echo %__ME%:__exec_self_as_BTM: ERROR: unable to open temporary file for BTM creation 1>&2 & @echo %__ME_echo% & @exit /B -1 )
if DEFINED __exec_self_as_BTM_localize echo @setLocal>> "%__exec_self_as_BTM_TEMPFILE%"
echo @:: [dynamic BTM, created from "%__ME_fullpath%"]>> "%__exec_self_as_BTM_TEMPFILE%"
echo @set __exec_self_as_BTM_TEMPFILE=>> "%__exec_self_as_BTM_TEMPFILE%"
echo set __ME=%__ME%>> "%__exec_self_as_BTM_TEMPFILE%"
echo set __ME_dir=%__ME_dir%>> "%__exec_self_as_BTM_TEMPFILE%"
echo set __ME_fullpath=%__ME_fullpath%>> "%__exec_self_as_BTM_TEMPFILE%"
echo @goto :__BTM_ENTRY >> "%__exec_self_as_BTM_TEMPFILE%"
::type "%~dpnx0" >> "%__exec_self_as_BTM_TEMPFILE%"
::type "%~f0" >> "%__exec_self_as_BTM_TEMPFILE%"
type "%__ME_fullpath%" >> "%__exec_self_as_BTM_TEMPFILE%"
:: correct setLocal/endLocal imbalance
if NOT DEFINED __exec_self_as_BTM_localize goto :__exec_self_as_BTM_call
endLocal & set __exec_self_as_BTM_TEMPFILE=%__exec_self_as_BTM_TEMPFILE%
:__exec_self_as_BTM_call
:: call new BTM incarnation
call "%__exec_self_as_BTM_TEMPFILE%" %*
:__exec_self_as_BTM_END
:: clean up temporaries
if EXIST "%__exec_self_as_BTM_TEMPFILE%" erase "%__exec_self_as_BTM_TEMPFILE%" >NUL
set __exec_self_as_BTM_TEMPFILE=
goto :EOF
::

::
:$$echo_state ( ref_RETURN )
:$echo_state ( ref_RETURN )
:_echo_state ( ref_RETURN )
:: determine and return the current echo state [ON/OFF]
:: RETURN == ON _or_ OFF [corresponding to the current echo state and usable as "echo %RETval%"]
:: NOTE: subs generally expect echo ON/OFF to be set prior to call for debugging so don't use any subroutine calls
@setLocal
@set "__DEBUG_KEY=@"
@set "__MEfn=_echo_state"
@set "_RETval=OFF"
@set "_RETvar=%~1"
@if NOT DEFINED temp ( set "temp=%tmp%" )
@if NOT EXIST "%temp%" ( set "temp=%tmp%" )
@if NOT EXIST "%temp%" ( set "temp=%LocalAppData%\Temp" )
@if NOT EXIST "%temp%" ( set "temp=%SystemRoot%\Temp" )
@if NOT EXIST "%temp%" ( set "temp=." )
:_echo_state_find_unique_temp
@set "tempfile=%temp%\%~nx0.echo_state.%RANDOM%.%RANDOM%.txt"
@if EXIST %tempfile% ( @goto :_echo_state_find_unique_temp )
@echo > "%tempfile%"
@type "%tempfile%" | "%SystemRoot%\System32\findstr" /i /r " [(]*on[)]*\.$" >nul 2>&1
@if "%ERRORLEVEL%"=="0" ( set _RETval=ON )
::@erase "%tempfile%" /Q > nul 2>&1
@endLocal & @set %_RETvar%^=%_RETval%
@if NOT 01 == 1.0 (@exit /b 0) else (@quit 0)
::

::
:$$tempfile ( ref_RETURN [PREFIX [EXTENSION]])
:$tempfile ( ref_RETURN [PREFIX [EXTENSION]])
:_tempfile ( ref_RETURN [PREFIX [EXTENSION]])
:: open a unique temporary file
:: RETURN == full pathname of temporary file (with given PREFIX and EXTENSION) [NOTE: has NO surrounding quotes]
:: PREFIX == optional filename prefix for temporary file
:: EXTENSION == optional extension (including leading '.') for temporary file [default == '.bat']
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_tempfile"
set "_RETval="
set "_RETvar=%~1"
set "prefix=%~nx2"
set "extension=%~3"
if NOT DEFINED extension ( set "extension=.txt")
:: attempt to find a temp directory
:: NOTE: see [How-TO check for directory-only existence] http://stackoverflow.com/a/12037613/43774
if NOT DEFINED temp ( set "temp=%tmp%" )
if NOT EXIST "%temp%" ( set "temp=%tmp%" )
if NOT EXIST "%temp%" ( set "temp=%LocalAppData%\Temp" )
if NOT EXIST "%temp%" ( set "temp=%SystemRoot%\Temp" )
if NOT EXIST "%temp%" ( goto :_tempfile_RETURN )    &:: undefined TEMP, RETURN (with NULL filename)
:_tempfile_find_unique_temp
set "_RETval=%temp%\%prefix%.TEMPFILE.%RANDOM%.%RANDOM%%extension%"
if EXIST %_RETval% ( goto :_tempfile_find_unique_temp )
:: instantiate tempfile [NOTE: this is an unavoidable race condition]
if NOT 01 == 1.0 (
    echo|set /p _OUTPUT="" >"%_RETval%" 2>nul
    ) else (
    echos >"%_RETval%" 2>nul
    )
if NOT EXIST "%_RETval%" (
    echo %__ME%:%__MEfn%: ERROR: unable to open tempfile [%_RETval%] 1>&2
    set "_RETval="
    )
:_tempfile_find_unique_temp_DONE
:_tempfile_RETURN
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:__PREinitialize ( [ ref_RETURN ] )
:: RETURN == COMSPEC name ('cmd', 'tcc')
::
:: BAT/CMD preinitialization for alternative shell compatibility [TCC/4NT, etc]
:: get COMSPEC filename and determine shell parsing type
:: NOTE: COMSPEC and parsing shell could be different if, for example, this BAT is executed from perl (perl defaults to using 'cmd' for system commands despite %COMSPEC% [see PERL5SHELL references in refs: http://perldoc.perl.org/perlwin32.html#Usage-Hints-for-Perl-on-Win32 , http://perldoc.perl.org/perlrun.html#ENVIRONMENT])
:: NOTE: MINIMIZE subroutine calls within __PREinitialize (and any called subroutines) to allow quick transition to BTM for TCC (especially, comment out "call :_echo_DEBUG_KEY ..." calls unless/until needed)
setLocal
set "__DEBUG_KEY=@@"
set "__MEfn=__PREinitialize"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
:__PREinitialize_CMDVARIABLES_CHECK
::TCC/4NT; expect "CMDVariables=Yes" in TCMD.ini to maximize compatibility
if NOT 01 == 1.0 ( goto :__PREinitialize_CMDVARIABLES_CHECK_DONE )
(set _TEMP=)
(set _TEMP(x86)=1)
set _TEMP=%_TEMP(x86)%
if "%_TEMP%" == "1" ( goto :__PREinitialize_CMDVARIABLES_CHECK_DONE )
echo %__ME%:%__MEfn%: ERROR: "CMDVariables=No" in TCMD.ini; make "CMDVariables=Yes" in TCMD.ini for CMD compatibility 1>&2
if 01 == 1.0 ( @echo %__ME_echo% & @quit -1 ) else ( @echo %__ME_echo% & @exit /B -1 ) &::TCC drops/ignores exit ERRORLEVEL from subroutines [so, use "quit" instead]
:__PREinitialize_CMDVARIABLES_CHECK_DONE
::check shell PARSE type vs COMSPEC
call :_filename_of _COMSPECNAME "%ComSpec%"
set "_PARSETYPE=%_COMSPECNAME%"
:: known parsers (CMD & TCC)
if 01 == 1.0 ( set "_PARSETYPE=tcc" ) else ( set "_PARSETYPE=cmd" )
REM call :_echo_DEBUG_KEY _COMSPECNAME="%_COMSPECNAME%"
REM call :_echo_DEBUG_KEY _PARSETYPE="%_PARSETYPE%"
:: if same, then assume user wants the current shell and continue
if /i [%_COMSPECNAME%]==[%_PARSETYPE%] ( goto :__PREinitialize_RETURN )
:: NOTE: this doesn't work ...
:: :: otherwise, restart using known COMSPEC with CMD.exe fallback (if found)
:: :: ?? use /d to avoid AutoRun for TCC and/or CMD shell execution
::if /i "%_COMSPECNAME%"=="tcc" (
::  "%ComSpec%" /x/c %0 %*
::  exit /B %ERRORLEVEL%
::  )
::set ComSpec=%SystemRoot%\\System32\\cmd.exe
::if EXIST "%ComSpec%" (
::  "%ComSpec%" /x/c %0 %*
::  exit /B %ERRORLEVEL%
::  )
:: echo %__ME%:%__MEfn%: ERROR: unmatched batch file parser and COMSPEC [unrecognized current COMSPEC and unable to find CMD.exe (at "%ComSpec%")]
:: exit /B -1
::
::
:__PREinitialize_RETURN
if /i NOT [%_COMSPECNAME%]==[%_PARSETYPE%] (
    echo %__ME%:%__MEfn%: ERROR: unmatched batch file parser and COMSPEC 1>&2
    if 01 == 1.0 ( @echo %__ME_echo% & @quit -1 ) else ( @echo %__ME_echo% & @exit /B -1 ) &::TCC drops/ignores exit ERRORLEVEL from subroutines [so, use "quit" instead]
    )
set "_RETval=%_COMSPECNAME%"
REM call :_echo_DEBUG_KEY _COMSPECNAME="%_COMSPECNAME%"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$filename_of ( ref_RETURN PATH )
:$filename_of ( ref_RETURN PATH )
:_filename_of ( ref_RETURN PATH )
:: RETURN == filename of PATH
:: NOTE: special processing to deal correctly with the case of "<DRIVE>:" ("<DRIVE>:" == "<DRIVE>:." == ".")
:: NOTE: _filename_of("") == ""
:: NOTE: _filename_of("\\") == _filename_of("\") == _filename_of("c:\") == _filename_of("c:\.") == ""
:: NOTE: _filename_of("c:") == _filename_of("c:.") == _filename_of(".")
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_filename_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "_path=%~2"
if NOT DEFINED _path ( goto :_filename_of_RETURN )
if "%_path%" == "\\" ( set "_path=\" )
::?:call :_drive_of drive "%~1"
::?:if /i "%drive%" == "%~1" ( set "_RETval=" & goto :_filename_of_RETURN )
::?:if /i "%drive%\" == "%~1" ( set "_RETval=" & goto :_filename_of_RETURN )
call :_rewrite_path_to_FQ_local _path _ "%_path%"
REM call :_echo_DEBUG_KEY _path="%_path%"
REM call :_echo_DEBUG_KEY _="%_%"
call :_param_tilde_N _RETval "%_path%"
:: remove trailing backslashes
call :_rtrim _RETval "%_RETval%" "\"
:_filename_of_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$rewrite_path_to_FQ_local ( ref_RETURN_path ref_RETURN_drive PATH )
:$rewrite_path_to_FQ_local ( ref_RETURN_path ref_RETURN_drive PATH )
:_rewrite_path_to_FQ_local ( ref_RETURN_path ref_RETURN_drive PATH )
:: RETURN_path == PATH, rewritten in a fully qualified (semi-canonical) form: removing extraneous trailing "\" or "\." and changing path to point to current drive (if a drive is specified)
:: RETURN_drive == original drive of PATH, "" if no drive was specified
:: NOTE:: changing PATH to refer to a similar "false" PATH on the local drive (for CMD and/or TCC) speeds up calculations for UNC network paths (avoiding network timeouts)
:: NOTE:: special processing is needed to deal with the fact that TCC acts out with almost unsuppressible errors for inaccessible and UNC PATHs [which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: NOTE:: changing PATH to refer to a local drive for TCC [avoids a loud & nasty TCC bug [ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://webcitation.org/63ua1bpOk]]
:: NOTE: assumes PATH has leading "X:", "\\...\...", "\...", or is a relative path (without leading "\")
:: NOTE: _rewrite_path_to_FQ_local("") => ("", "")
:: NOTE: _rewrite_path_to_FQ_local("\\") == _rewrite_path_to_FQ_local("\")
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_rewrite_path_to_FQ_local"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETvar_drive=%~2"
set "_RETval=%~3"
set "drive="
REM call :_echo_DEBUG_KEY PATH="%_RETval%"
if NOT DEFINED _RETval ( goto :_rewrite_path_to_FQ_local_RETURN )
set "_path=%_RETval%"
if "%_path%" == "." ( goto :_rewrite_path_to_FQ_local_RETURN )
set local_drive=
call :_split_drive_path_of drive _path "%_path%"
if NOT DEFINED _path ( set "_path=." )
REM call :_echo_DEBUG_KEY drive="%drive%"
REM call :_echo_DEBUG_KEY _path="%_path%"
:_rewrite_path_to_FQ_local_LOOP
if NOT DEFINED _path ( goto :_rewrite_path_to_FQ_local_LOOP_DONE )
if "%_path%" == "\\" ( set "_path=\" )
if "%_path%" == "\." ( set "_path=\" )
if "%_path%" == "\" ( goto :_rewrite_path_to_FQ_local_LOOP_DONE )
:: TCC doesn't handle trailing "\." or "\" correctly, so remove them
REM call :_echo_DEBUG_KEY 2_path="%_path%"
:_rewrite_path_to_FQ_local_LOOP_test_1
if NOT "%_path:~-2,2%" == "\." ( goto :_rewrite_path_to_FQ_local_LOOP_test_2 )
set "_path=%_path:~0,-2%"
goto :_rewrite_path_to_FQ_local_LOOP
:_rewrite_path_to_FQ_local_LOOP_test_2
REM call :_echo_DEBUG_KEY 3_path="%_path%"
if NOT "%_path:~-1,1%" == "\" ( goto :_rewrite_path_to_FQ_local_LOOP_test_3 )
set "_path=%_path:~0,-1%"
goto :_rewrite_path_to_FQ_local_LOOP
:_rewrite_path_to_FQ_local_LOOP_test_3
if NOT "%_path:~0,2%" == "\\" ( goto :_rewrite_path_to_FQ_local_LOOP_test_DONE )
set "_RETval=%_path:~1%"
:_rewrite_path_to_FQ_local_LOOP_test_DONE
:_rewrite_path_to_FQ_local_LOOP_DONE
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
if NOT DEFINED drive ( goto :_rewrite_path_to_FQ_local_DONE )
if NOT DEFINED local_drive ( set "local_drive=%SYSTEMDRIVE%" )
if NOT DEFINED local_drive ( set "local_drive=%SYSTEMROOT:~0,2%" )
if NOT DEFINED local_drive ( set "local_drive=%~d0" )
REM call :_echo_DEBUG_KEY local_drive="%local_drive%"
set "_RETval=%local_drive%%_path%"
:_rewrite_path_to_FQ_local_DONE
:_rewrite_path_to_FQ_local_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set "%_RETvar%=%_RETval%" & set "%_RETvar_drive%=%drive%"
goto :EOF
::

::
:$$drive_of ( ref_RETURN PATH )
:$drive_of ( ref_RETURN PATH )
:_drive_of ( ref_RETURN PATH )
:: RETURN == drive of PATH
:: NOTE: assumes PATH has leading "X:", "\\SERVER"; PATHs without a drive indicator return NULL
:: NOTE: drive_of("") == ""; drive_of("\\SERVER\PATH") == "\\SERVER"
:: NOTE: special UNC paths: drive_of("\\?\UNC\PATH") => drive_of("\\PATH"); drive_of("\\?\PATH") == drive_of("\\.\PATH") => drive_of("PATH")
:: ref: [Naming Files, Paths, and Namespaces - MSDN] http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx @@ http://archive.is/EcTrM @@ http://webcitation.org/6IwYVd1Cn
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_drive_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "_path=%~2"
call :_split_drive_path_of _RETval _ "%_path%"
::if NOT DEFINED _RETval ( set "_RETval=%~d2" ) &:: causes TCC errors for non-existent PATHs
:_drive_of_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$FQ_drive_of ( ref_RETURN PATH )
:$FQ_drive_of ( ref_RETURN PATH )
:_FQ_drive_of ( ref_RETURN PATH )
:: RETURN == fully qualified (canonical) directory of PATH
:: NOTE: _FQ_drive_of("") == ""
:: NOTE: _FQ_drive_of("\\") == _FQ_drive_of("\") == _FQ_drive_of("\.")
:: NOTE: _FQ_drive_of("c:") == _FQ_drive_of("c:.")
:: NOTE: _FQ_drive_of("c:\") == _FQ_drive_of("c:\.") == "c:\"
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_FQ_drive_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: avoid TCC path parsing errors for null strings
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_FQ_drive_of_RETURN )
call :_rewrite_path_to_FQ_local _ drive "%_RETval%"
if NOT DEFINED drive ( goto :_FQ_drive_of_DONE )
:_FQ_drive_of_DONE
if NOT DEFINED drive ( set "drive=%SYSTEMDRIVE%" )
if NOT DEFINED drive ( set "drive=%SYSTEMROOT:~0,2%" )
if NOT DEFINED drive ( set "drive=%~d0" )
REM call :_echo_DEBUG_KEY drive="%drive%"
:_FQ_drive_of_DONE
set "_RETval=%drive%"
:_FQ_drive_of_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$split_drive_path_of ( ref_RETURN_DRIVE ref_RETURN_PATH PATH )
:$split_drive_path_of ( ref_RETURN_DRIVE ref_RETURN_PATH PATH )
:_split_drive_path_of ( ref_RETURN_DRIVE ref_RETURN_PATH PATH )
:: RETURN_DRIVE == drive of PATH
:: RETURN_PATH == PATH with drive prefix removed
:: NOTE: assumes PATH has leading "X:", "\\", "\...", or is a relative path (without leading "\")
:: NOTE: drive_of("") == ""; drive_of("\\SERVER\PATH") == "\\SERVER"
:: NOTE: special UNC paths: drive_of("\\?\UNC\PATH") => drive_of("\\PATH"); drive_of("\\?\PATH") => drive_of("PATH"); drive_of("\\.\DEVICE\PATH") => "\\.\DEVICE"
:: ref: [Naming Files, Paths, and Namespaces - MSDN] http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx @@ http://archive.is/EcTrM @@ http://webcitation.org/6IwYVd1Cn
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_split_drive_path_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval_drive="
set "_RETvar_drive=%~1"
set "_RETvar_path=%~2"
set "_path=%~3"
:_split_drive_path_of_START
if NOT DEFINED _path ( goto :_split_drive_path_of_RETURN )
if "%_path%" == "\\" ( goto :_split_drive_path_of_RETURN )
if NOT "%_path:~0,2%" == "\\" ( goto :_split_drive_path_of_NONUNC )
set "_RETval_drive=\\"
set "_path=%_path:~2%"
:_split_drive_path_of_TEST_1
if NOT "%_path:~0,6%" == "?\UNC\" ( goto :_split_drive_path_of_TEST_2 )
set "_path=\\%_path:~6%"
goto :_split_drive_path_of_UNC_LOOP
:_split_drive_path_of_TEST_2
if NOT "%_path:~0,2%" == "?\" ( goto :_split_drive_path_of_TEST_3 )
set "_path=%_path:~2%"
goto :_split_drive_path_of_START
:_split_drive_path_of_TEST_3
if NOT "%_path:~0,2%" == ".\" ( goto :_split_drive_path_of_TEST_4 )
set "_RETval_drive=\\.\"
set "_path=%_path:~2%"
:_split_drive_path_of_TEST_4
:_split_drive_path_of_UNC_LOOP
if NOT DEFINED _path ( goto :_split_drive_path_of_UNC_LOOP_DONE )
if "%_path:~0,1%" == "\" ( goto :_split_drive_path_of_UNC_LOOP_DONE )
set "_RETval_drive=%_RETval_drive%%_path:~0,1%"
set "_path=%_path:~1%"
goto :_split_drive_path_of_UNC_LOOP
:_split_drive_path_of_UNC_LOOP_DONE
goto :_split_drive_path_of_RETURN
:_split_drive_path_of_NONUNC
if NOT "%_path:~1,1%" == ":" ( goto :_split_drive_path_of_TEST_6 )
set "_RETval_drive=%_path:~0,2%"
set "_path=%_path:~2%"
goto :_split_drive_path_of_RETURN
:_split_drive_path_of_TEST_6
::set "_RETval_drive=%~d3"
:_split_drive_path_of_RETURN
REM call :_echo_DEBUG_KEY _RETvar_drive="%_RETvar_drive%"
REM call :_echo_DEBUG_KEY _RETval_drive="%_RETval_drive%"
REM call :_echo_DEBUG_KEY _RETvar_path="%_RETvar_path%"
REM call :_echo_DEBUG_KEY _RETval_path="%_path%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
:: return values via a single line with surrounding double-quotes; this is fine here, given double-quotes are illegal in NTFS filenames
endLocal & set "%_RETvar_drive%=%_RETval_drive%" & set "%_RETvar_path%=%_path%"
goto :EOF
::

::
:$$rtrim ( ref_RETURN ITEM [CHARSET] )
:$rtrim ( ref_RETURN ITEM [CHARSET] )
:_rtrim ( ref_RETURN ITEM [CHARSET] )
:: trim characters in CHARSET from right-side of ITEM
:: RETURN = ITEM with rightmost CHARSET characters removed
:: NOTE: CHARSET defaults to "<SPACE>" if NULL/missing
:: refs: [Variable editing] http://ss64.com/nt/syntax-substring.html, [How to trim whitespace from a string] http://www.experts-exchange.com/OS/Microsoft_Operating_Systems/MS_DOS/Q_23816304.html
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_rtrim"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "item=%~2"
if 1.0 == 01 (
    set item=%@unquotes[%2]
    )
set "charset=%~3"
if 1.0 == 01 (
    set charset=%@unquotes[%3]
    )
if NOT DEFINED charset ( set "charset= " )
REM call :_echo_DEBUG_KEY item="%item%"
REM call :_echo_DEBUG_KEY charset="%charset%"
:: change any internal double quotes to chr(255) (avoids syntax errors during the character comparison and removal process) [ NOTE: may have internal double quotes, so no outer quotes for set; this also creates a problem with internal ()'s if the set is enclosed in a block, so use a goto around it as needed]
if NOT DEFINED item ( goto :_rtrim_LOOP_ch )
set "item=%item:"=Â¸%"
set "charset=%charset:"=Â¸%"
set "chars=%charset%"
:_rtrim_LOOP_ch
REM call :_echo_DEBUG_KEY LOOP.item="%item%"
REM call :_echo_DEBUG_KEY charset="%charset%"
REM call :_echo_DEBUG_KEY LOOP.chars="%chars%"
set "ch="
if DEFINED chars ( set "ch=%chars:~0,1%" & set "chars=%chars:~1%" )
if NOT DEFINED ch ( goto :_rtrim_LOOP_DONE )
:_rtrim_LOOP_removal
if NOT DEFINED item ( goto :_rtrim_LOOP_DONE )
set "last_ch="
if DEFINED item ( set "last_ch=%item:~-1%" )
REM call :_echo_DEBUG_KEY item="%item%"
REM call :_echo_DEBUG_KEY ch="%ch%"
REM call :_echo_DEBUG_KEY last_ch="%last_ch%"
if /i "%last_ch%" == "%ch%" (
    set "item=%item:~0,-1%"
    set "chars=%charset%"
    goto :_rtrim_LOOP_removal
    )
goto :_rtrim_LOOP_ch
:_rtrim_LOOP_DONE
:_rtrim_RETURN
if NOT DEFINED item ( goto :_rtrim_RETURN_translate_DONE )
:: return any double quotes to ITEM
set item=%item:Â¸=^"%
:: " [balance double quote for editor parsing]
:_rtrim_RETURN_translate_DONE
set _RETval=%item%
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$param_tilde_N ( ref_RETURN PATH )
:$param_tilde_N ( ref_RETURN PATH )
:_param_tilde_N ( ref_RETURN PATH )
:: NOTE: for TCC, assume that PATH is on (or has been forced onto) an accessible drive and not a UNC pathname [necessary to avoid insuppressible TCC parsing errors; which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: RETURN == name of PATH
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_param_tilde_N"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
if NOT DEFINED _RETval ( goto :_param_tilde_N_RETURN )
set "_RETval=%~n2"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
:_param_tilde_N_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$echo_DEBUG ( [ TEXT ... ] )
:$echo_DEBUG ( [ TEXT ... ] )
:_echo_DEBUG ( [ TEXT ... ] )
:: used to help avoid the CMD/TCC BUG which causes a script breaking error if ()'s (more specifically, closed parens) are found within an IF() block
:: NOTE: __DEBUG is GLOBAL to this function (and MUST be, because the shift command doesn't change subsequent %* uses {so, there is no way to pass vars into the function with arbitrary following TEXT})
if NOT DEFINED __DEBUG ( goto :_echo_DEBUG_RETURN )
if NOT DEFINED __MEfn ( goto :_echo_DEBUG_NO_MEFN )
echo %__ME%:%__MEfn%: {{DEBUG}} %*
goto :_echo_DEBUG_RETURN
:_echo_DEBUG_NO_MEFN
echo %__ME%: {{DEBUG}} %*
goto :_echo_DEBUG_RETURN
:_echo_DEBUG_RETURN
goto :EOF
::

::
:$$echo_DEBUG_KEY ( [ TEXT ... ] )
:$echo_DEBUG_KEY ( [ TEXT ... ] )
:_echo_DEBUG_KEY ( [ TEXT ... ] )
:: used to help avoid the CMD/TCC BUG which causes a script breaking error if ()'s (more specifically, closed parens) are found within an IF() block
:: NOTE: __DEBUG and __DEBUG_KEY are GLOBAL to this function (and MUST be, because the shift command doesn't change subsequent %* uses {so, there is no way to pass vars into the function with arbitrary following TEXT})
if NOT DEFINED __DEBUG ( goto :_echo_DEBUG_KEY_RETURN )
if NOT "%__DEBUG%" == "%__DEBUG_KEY%" ( goto :_echo_DEBUG_KEY_RETURN )
if NOT DEFINED __MEfn ( goto :_echo_DEBUG_KEY_NO_MEFN )
echo %__ME%:%__MEfn%: {{DEBUG: %__DEBUG%}} %*
goto :_echo_DEBUG_KEY_RETURN
:_echo_DEBUG_KEY_NO_MEFN
echo %__ME%: {{DEBUG: %__DEBUG%}} %*
goto :_echo_DEBUG_KEY_RETURN
:_echo_DEBUG_KEY_RETURN
goto :EOF
::

::
:$$echo_item_DEBUG_KEY ( DEBUG DEBUG_KEY ME MEfn ITEM )
:$echo_item_DEBUG_KEY ( DEBUG DEBUG_KEY ME MEfn ITEM )
:_echo_item_DEBUG_KEY ( DEBUG DEBUG_KEY ME MEfn ITEM )
:: used to help avoid the CMD/TCC BUG which causes a script breaking error if ()'s (more specifically, closed parens) are found within an IF() block
:: NOTE: using a single echo'd item allows passage of other vars into the function
setLocal
set __DEBUG=%~1
set __DEBUG_KEY=%~2
set __ME=%~3
set __MEfn=%~4
set item=%~5
@call :_echo_DEBUG_KEY %item%
:_echo_item_DEBUG_KEY_RETURN
endLocal
goto :EOF
::

:::: [ end of __PREinitialize section (contains all required function dependencies) ]

::
:$$is_same_command ( ref_RETURN FILENAME1 FILENAME2 )
:$is_same_command ( ref_RETURN FILENAME1 FILENAME2 )
:_is_same_command ( ref_RETURN FILENAME1 FILENAME2 )
:: determine if FILENAME1 is the same as FILENAME2
:: RETURN == (BOOLEAN as undef/1) whether FILENAMEs are the same
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_same_command"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
:: more than 3 ARGS implies multiple parts for FILENAME1 and/or FILENAME2 (therefore, NOT testable and defined as NOT the same)
REM call :_echo_DEBUG_KEY 4thARG?="%~4"
if NOT "%~4"=="" ( goto :_is_same_command_RETURN )
:: deal with NULL extensions (if both NULL, leave alone; otherwise, use the non-NULL extension for both)
set "_f2=%~2"
set "_f3=%~3"
if "%~x2"=="" ( call :_path_of_file_in_PATH _p2 "%_f2%" "%PATHEXT%" ) else ( call :_path_in_PATH _p2 "%_f2%" )
if "%~x3"=="" ( call :_path_of_file_in_PATH _p3 "%_f3%" "%PATHEXT%" ) else ( call :_path_in_PATH _p3 "%_f3%" )
REM call :_echo_DEBUG_KEY p2="%_p2%"
REM call :_echo_DEBUG_KEY p3="%_p3%"
if /i "%_p2%"=="%_p3%" ( set "_RETval=1" )
:_is_same_command_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%~1"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
endLocal & set "%~1=%_RETval%"
goto :EOF
::

::
:$$is_similar_command ( ref_RETURN FILENAME1 FILENAME2 )
:$is_similar_command ( ref_RETURN FILENAME1 FILENAME2 )
:_is_similar_command ( ref_RETURN FILENAME1 FILENAME2 )
:: determine if FILENAME1 is similar to FILENAME2
:: RETURN == (BOOLEAN as undef/1) whether FILENAMEs are similar
:: NOTE: not _is_SAME_command; that entails parsing PATHEXT and concatenating each EXT for any argument with a NULL extension
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_similar_command"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
:: more than 3 ARGS implies multiple parts for FILENAME1 and/or FILENAME2 (therefore, NOT testable and defined as NOT the same)
if NOT "%~4"=="" ( goto :_is_similar_command_RETURN )
:: deal with NULL extensions (if both NULL, leave alone; otherwise, use the non-NULL extension for both)
set _EXT_2=%~x2
set _EXT_3=%~x3
if NOT "%_EXT_2%"=="%_EXT_3%" if "%_EXT_2%"=="" (
    call :_is_similar_command _RETval "%~2%_EXT_3%" "%~3"
    goto :_is_similar_command_RETURN
    )
if NOT "%_EXT_2%"=="%_EXT_3%" if "%_EXT_3%"=="" (
    call :_is_similar_command _RETval "%~2" "%~3%_EXT_2%"
    goto :_is_similar_command_RETURN
    )
::if /i "%~dnpx2"=="%~dnpx3" ( set "_RETval=1" )  &:: FAILS for shells executed with non-fully qualified paths (eg, subshells called with 'cmd.exe' or 'tcc')
if /i "%~$PATH:2"=="%~$PATH:3" ( set "_RETval=1" )
:_is_similar_command_RETURN
endLocal & set "%~1=%_RETval%"
goto :EOF
::

::
:$$is_exec_from_console ( ref_RETURN )
:$is_exec_from_console ( ref_RETURN )
:_is_exec_from_console ( ref_RETURN )
:: determine if script is being executed directly from the console window (rather than from an explorer)
:: RETURN == (BOOLEAN as undef/1) whether script is executed from console
:: NOTE: if %cmdcmdline% has multiple parts, the script is NOT under direct console execution [!! except for elevate or run `cmd /k ...`]
:: NOTE: ToDO: check for ...\CMD.exe or ...\CMD.exe /k [elevate or run] vs ...\CMD.exe /c [explorer or run]
:: NOTE:   ... elevate.x32.exe uses C:\Windows\SysWOW64\CMD.exe on 64-bit systems; deal with C:\Windows\System32\CMD.exe and C:\Windows\SysWOW64\CMD.exe
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_exec_from_console"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval=0"
set _RETvar=%~1
call :_is_same_command _RETval "%COMSPEC%" %cmdcmdline%
:_is_exec_from_console_RETURN
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_transient_shell ( ref_RETURN )
:$is_transient_shell ( ref_RETURN )
:_is_transient_shell ( ref_RETURN )
:: determine if script is being executed in a transient shell console window
:: RETURN == (BOOLEAN as undef/1) whether script is executed from console
:: NOTE: known possibilities: `...\CMD.exe`, `...\CMD.exe /k` [via elevate or run], `...\CMD.exe /c` [via explorer or run]
:: NOTE: 32-bit commands (eg, elevate.x32.exe) may see `C:\Windows\SysWOW64\CMD.exe` on 64-bit systems; deal with `C:\Windows\System32\CMD.exe` and `C:\Windows\SysWOW64\CMD.exe`
:: [CMD/TCC] /C == transient shell carries out the command specified by string and then terminates
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=$is_transient_console"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval=0"
set _RETvar=%~1
call :_create_list ccl_token_list %cmdcmdline%
call :_is_in_list _RETval "/c" "%ccl_token_list%"
:_is_transient_shell_RETURN
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_elevated ( ref_RETURN )
:$is_elevated ( ref_RETURN )
:_is_elevated ( ref_RETURN )
:: determine if script is operating under privilege elevation
:: RETURN == (BOOLEAN as undef/1) whether script has elevated permissions
:: NOTE: pre-VISTA OS do not have UAC limited permissions and are therefore always considered "elevated"
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_elevated"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set _RETvar=%~1
shift
::
set _RETval=1
call :_win_os_version _version_name _version_N
IF /i %_version_N% LSS 6 ( goto :_is_elevated_RETURN )
call :_is_UAC_elevated _RETval
::
:_is_elevated_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_UAC_elevated ( ref_RETURN )
:$is_UAC_elevated ( ref_RETURN )
:_is_UAC_elevated ( ref_RETURN )
:: elevation check
:: ref: <http://blogs.technet.com/jhoward/archive/2008/11/19/how-to-detect-uac-elevation-from-vbscript.aspx>[`@`](https://archive.is/nS90V)
:: ref: <http://stackoverflow.com/questions/7985755/how-to-detect-if-cmd-is-running-as-administrator-has-elevated-privileges>[`@`](https://archive.is/5uENM)
:: ref: <https://stackoverflow.com/questions/4051883/batch-script-how-to-check-for-admin-rights>[`@`](https://archive.is/M1tFE)
:: RETURN == (BOOLEAN as undef/1) whether script has UAC elevated permissions
:: if VISTA+, run %SystemRoot%/System32/whoami.exe /groups and check for "Mandatory Label\High Mandatory Level" - if missing -> NOT elevated
:: using "net session" instead as a more robust method of detection
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_UAC_elevated"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set _RETvar=%~1
call :_win_os_version _version_name _version_N
IF /i %_version_N% LSS 6 ( goto :_is_UAC_elevated_RETURN )
set "ERRORLEVEL="
:: call `net session` twice to avoid corner case where `at` has been called previously
call "%SystemRoot%\\System32\\net" session >nul 2>&1
call "%SystemRoot%\\System32\\net" session >nul 2>&1
IF %ERRORLEVEL% EQU 0 ( SET "_RETval=true" )
:_is_UAC_elevated_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_devmode ( ref_RETURN )
:$is_devmode ( ref_RETURN )
:_is_devmode ( ref_RETURN )
:: Win10+ Developer Mode
:: ref: <https://www.hanselman.com/blog/Windows10DeveloperMode.aspx>[`@`](https://archive.is/LdFLJ)
:: ref: <https://en.wikipedia.org/wiki/Windows_10_version_history>[`@`](https://archive.is/LkhxO)
:: ref: <https://stackoverflow.com/questions/41231586/how-to-detect-if-developer-mode-is-active-on-windows-10>[`@`](https://archive.is/63txT)
:: ref: <https://stackify.com/windows-10-developer-mode>[`@`](https://archive.is/dObTP)
:: RETURN == (BOOLEAN as undef/1) whether Win10 Developer Mode is enabled
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_devmode"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set _RETvar=%~1
:: ? is check for Win10 needed?
call :_win_os_version _version_name _version_N _version_V _version_V_Major _version_V_minor _version_V_build
if %_version_N% LSS 10 ( goto :_is_devmode_RETURN )
if %_version_V_minor% EQU 0 if %_version_V_build% LSS 14393 ( goto :_is_devmode_RETURN )
::
set "ERRORLEVEL="
for /F "tokens=1,2,3" %%g in ('reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock" /v AllowDevelopmentWithoutDevLicense') do (
    if /i "%%g" == "AllowDevelopmentWithoutDevLicense" ( set "devmode=%%i" )
    )
IF %ERRORLEVEL% EQU 0 IF DEFINED devmode IF /i NOT "%devmode%"=="0x0" ( SET "_RETval=true" )
:_is_devmode_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$has_privilege ( ref_RETURN PRIV_NAME )
:$has_privilege ( ref_RETURN PRIV_NAME )
:_has_privilege ( ref_RETURN PRIV_NAME )
:: privilege check
:: ref: http://stackoverflow.com/questions/11607389/how-to-view-user-privileges-using-windows-cmd
:: ref: https://social.technet.microsoft.com/Forums/windowsserver/en-US/e24a35b3-fb72-4918-8e51-562e2ad8d8f5/what-is-the-state-column-returned-by-whoami-priv?forum=winserversecurity @@ https://archive.today/uZMlX
:: RETURN == (BOOLEAN as undef/1) whether script has privilege by the name PRIV_NAME
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_has_privilege"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set _RETvar=%~1
set priv_name=%~2 &:: privilege name to search
::call :_win_os_version _version_name _version_N
::IF /i %_version_N% LSS 6 ( goto :_is_UAC_elevated_RETURN )
set "ERRORLEVEL="
call "%SystemRoot%\\System32\\whoami" /priv | call "%SystemRoot%\\System32\\FINDSTR" /IL /C:"%priv_name%" > NUL
IF %ERRORLEVEL% EQU 0 ( SET "_RETval=true" )
:_has_privilege_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$can_symlink ( ref_RETURN )
:$can_symlink ( ref_RETURN )
:_can_symlink ( ref_RETURN )
:: can create symlinks
:: NOTE: UAC removes symlink creation priv (SeCreateSymbolicLinkPrivilege; seen with `whoami /priv` or `whoami /all`)
:: ref: <https://blogs.windows.com/buildingapps/2016/12/02/symlinks-windows-10>[`@`](http://archive.is/fUa9q)
:: ref: <https://stackoverflow.com/questions/15320550/why-is-secreatesymboliclinkprivilege-ignored-on-windows-8>[`@`](https://archive.is/3M0Ib)
:: RETURN == (BOOLEAN as undef/1) whether script has ability to create symlinks
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_can_symlink"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set _RETvar=%~1
if NOT defined _RETval call :_has_privilege _RETval SeCreateSymbolicLinkPrivilege
if NOT defined _RETval call :_is_devmode _RETval
:_can_symlink_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_exit_pause_needed ( ref_PAUSE_FLAG [in/out] )
:$is_exit_pause_needed ( ref_PAUSE_FLAG [in/out] )
:_is_exit_pause_needed ( ref_PAUSE_FLAG [in/out] )
:: determine if a pause is needed before script exit (if called from explorer via a transient shell, etc)
:: PAUSE_FLAG may be preset to a value (0==false/non-0==true) prior to calling this function is called to allow executor control of pause on exit, overriding normal logic as noted here
:: %PAUSE_FLAG% == not defined :: normal logic, PAUSE needed if script executed in a transient console shell
:: %PAUSE_FLAG% == 0 :: override, no PAUSE needed
:: %PAUSE_FLAG% == "1, will pause at top level", no PAUSE needed in current or called scripts
:: %PAUSE_FLAG% == 1 or <OTHER> :: override, PAUSE needed, but set return value to signal value ("1, will pause at top level")
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_exit_pause_needed"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval=1, will pause at top level"
set _RETvar=%~1
call set _INPUT_PAUSE=%%%_RETvar%%%
if DEFINED _INPUT_PAUSE ( if /I "%_INPUT_PAUSE%"=="0" ( set "_RETval=0" & goto :_is_exit_pause_needed_RETURN ) )
if DEFINED _INPUT_PAUSE ( if /I "%_INPUT_PAUSE%"=="1, will pause at top level" ( set "_RETval=0" & goto :_is_exit_pause_needed_RETURN ) )
if DEFINED _INPUT_PAUSE ( goto :_is_exit_pause_needed_RETURN )
call :_is_transient_shell _TRANSIENT
if NOT DEFINED _TRANSIENT ( set "_RETval=0" )
:_is_exit_pause_needed_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY "%_RETvar%"="%_INPUT_PAUSE%"
REM call :_echo_DEBUG_KEY _TRANSIENT="%_TRANSIENT%"
REM call :_echo_DEBUG_KEY _is_exit_pause_needed="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$win_os_version ( ref_RETURN_NAME [ ref_RETURN_N [ [ [ [ [ref_RETURN_V] ref_RETURN_V_Major ] ref_RETURN_V_minor ] ref_RETURN_V_build ] ref_RETURN_arch ] ] )
:$win_os_version ( ref_RETURN_NAME [ ref_RETURN_N [ [ [ [ [ref_RETURN_V] ref_RETURN_V_Major ] ref_RETURN_V_minor ] ref_RETURN_V_build ] ref_RETURN_arch ] ] )
:_win_os_version ( ref_RETURN_NAME [ ref_RETURN_N [ [ [ [ [ref_RETURN_V] ref_RETURN_V_Major ] ref_RETURN_V_minor ] ref_RETURN_V_build ] ref_RETURN_arch ] ] )
:: ToDO: add notes about continuing maintenance needs for increasing Windows versions
:: ToDO: make more robust: 1) check for existence of used EXEs; 2) check for earlier versions
:: ToDO: ? change "XP.x64" to "XP" with N_bit == "64"
:: DONE: ToDO: add _ARCH, _V, _V_b, _V_Mm as optional return values
:: find Windows OS version (for Windows versions from Windows 2000 on)
:: RETURN_NAME == current OS name ["7", "2008.R2", "2008", "Vista", "2003", "XP.x64", "XP", NULL]
:: RETURN_N == current OS version [ 0 == unknown ]
:: ref: http://serverfault.com/questions/124848/using-systeminfo-to-get-the-os-name
:: ref: http://stackoverflow.com/questions/1792740/how-to-tell-what-version-of-windows-and-or-cmd-exe-a-batch-file-is-running-on
:: ref: http://pario.no/2011/06/19/list-installed-windows-updates-using-wmic @@ http://www.webcitation.org/66a7J58OK
:: ref: http://tech-wreckblog.blogspot.com/2009/11/wmic-command-line-kung-fu.html @@ http://www.webcitation.org/66a7MbiGf
:: ref: http://roddotnet.blogspot.com/2008/08/how-to-detect-windows-vista-in-batch.html
:: ref: [MS Windows Version Numbers] http://msdn.microsoft.com/en-us/library/windows/desktop/ms724832(v=vs.85).aspx @@ http://www.webcitation.org/66FzghSQU
:: ref: http://malektips.com/xp_dos_0025.html @@ http://www.webcitation.org/66G00alzC
:: ref: http://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions @@ https://archive.today/JtQ5J
:: NOTE: "systeminfo 2> nul" is used to avoid spurious progress output from systeminfo
:: ToDO: investigate use of "%SystemRoot%\System32\cmd.exe" /x/d/c "VER instead
:: ToDO: investigate improved efficiency if VER and systeminfo could be executed just once with value saved into a variable with "ECHO %VAR% | findstr ..."
:: ToDO: DONE: change to use wmic
:: NOTE: not using FOR ... in order to use this same function in Autorun :: might be able to use for ('cmd /d ...')
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_win_os_version"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval_NAME="
set _RETval_N=0
set _RETvar=%~1
shift
set _RETvar_N=%~1
shift
set _RETvar_V=%~1
shift
set _RETvar_V_Major=%~1
shift
set _RETvar_V_minor=%~1
shift
set _RETvar_V_build=%~1
shift
set _RETvar_ARCH=%~1
::*::
:: ref: http://serverfault.com/questions/124848/using-systeminfo-to-get-the-os-name
:: ref: http://stackoverflow.com/questions/1792740/how-to-tell-what-version-of-windows-and-or-cmd-exe-a-batch-file-is-running-on
:: ref: http://pario.no/2011/06/19/list-installed-windows-updates-using-wmic @@ http://www.webcitation.org/66a7J58OK
:: ref: http://tech-wreckblog.blogspot.com/2009/11/wmic-command-line-kung-fu.html @@ http://www.webcitation.org/66a7MbiGf
::
:: default values for unknown windows version: version=NULL
SET _win_os_version=
SET _win_os_version_ARCH=32
SET _win_os_version_N=0
SET _win_os_version_FIND=%SystemRoot%\\System32\\FINDSTR
SET _win_os_version_INFO=%SystemRoot%\\System32\\WBEM\\wmic
SET "ERRORLEVEL="
"%SystemRoot%\System32\cmd.exe" /x/d/c "echo. | call "%_win_os_version_INFO%" os get osarchitecture /format:value 2> NUL | call "%_win_os_version_FIND%" /IR /C:"OSArchitecture=64.*" > NUL"
IF "%ERRORLEVEL%" == "0" (
    SET "_win_os_version_ARCH=64"
    )
for /f "tokens=4 delims=[] " %%G in ('call VER') do set "_win_os_version_V=%%G"
for /f "tokens=1,2,3* delims=." %%G in ("%_win_os_version_V%") do (
        set _win_os_version_N=%%G
        set _win_os_version_V_Mm=%%G.%%H
        set _win_os_version_V_Major=%%G
        set _win_os_version_V_minor=%%H
        set _win_os_version_V_build=%%I
        set _win_os_version_V_ubr=%%J
        )
:_win_os_version_check_5_0
if NOT "%_win_os_version_V_Mm%" == "5.0" ( goto :_win_os_version_check_5_0_DONE )
:: : Windows 2000
SET "_win_os_version=2000"
goto :_win_os_version_FOUND
:_win_os_version_check_5_0_DONE
:_win_os_version_check_5_1
if NOT "%_win_os_version_V_Mm%" == "5.1" ( goto :_win_os_version_check_5_1_DONE )
:: : Windows XP
SET "_win_os_version=XP"
goto :_win_os_version_FOUND
:_win_os_version_check_5_1_DONE
:_win_os_version_check_5_2
if NOT "%_win_os_version_V_Mm%" == "5.2" ( goto :_win_os_version_check_5_2_DONE )
:: : Windows Server 2003 & Windows XP 64-bit
SET "_win_os_version=2003"
"%SystemRoot%\System32\cmd.exe" /x/d/c "echo. | call "%_win_os_version_INFO%" os get caption /format:value 2> NUL | call "%_win_os_version_FIND%" /IR /C:"Caption=.*Windows.XP.*" > NUL"
IF "%ERRORLEVEL%" == "0" (
    SET "_win_os_version=XP.x64"
    )
goto :_win_os_version_FOUND
:_win_os_version_check_5_2_DONE
:_win_os_version_check_6_0
if NOT "%_win_os_version_V_Mm%" == "6.0" ( goto :_win_os_version_check_6_0_DONE )
:: : Windows Vista & Windows Server 2008
SET "_win_os_version=Vista"
"%SystemRoot%\System32\cmd.exe" /x/d/c "echo. | call "%_win_os_version_INFO%" os get caption /format:value 2> NUL | call "%_win_os_version_FIND%" /IR /C:"Caption=.*Server.*" > NUL"
IF "%ERRORLEVEL%" == "0" (
    SET "_win_os_version=2008"
    )
goto :_win_os_version_FOUND
:_win_os_version_check_6_0_DONE
:_win_os_version_check_6_1
if NOT "%_win_os_version_V_Mm%" == "6.1" ( goto :_win_os_version_check_6_1_DONE )
:: : Windows 7 & Windows Server 2008 R2
SET "_win_os_version=7"
"%SystemRoot%\System32\cmd.exe" /x/d/c "echo. | call "%_win_os_version_INFO%" os get caption /format:value 2> NUL | call "%_win_os_version_FIND%" /IR /C:"Caption=.*Server.*" > NUL"
IF "%ERRORLEVEL%" == "0" (
    SET "_win_os_version=2008.R2"
    )
goto :_win_os_version_FOUND
:_win_os_version_check_6_1_DONE
:_win_os_version_check_6_2
if NOT "%_win_os_version_V_Mm%" == "6.2" ( goto :_win_os_version_check_6_2_DONE )
:: : Windows 8 & Windows Server 2012
SET "_win_os_version=8"
"%SystemRoot%\System32\cmd.exe" /x/d/c "echo. | call "%_win_os_version_INFO%" os get caption /format:value 2> NUL | call "%_win_os_version_FIND%" /IR /C:"Caption=.*Server.*" > NUL"
IF "%ERRORLEVEL%" == "0" (
    SET "_win_os_version=2012"
    )
goto :_win_os_version_FOUND
:_win_os_version_check_6_2_DONE
:_win_os_version_check_6_3
if NOT "%_win_os_version_V_Mm%" == "6.3" ( goto :_win_os_version_check_6_3_DONE )
:: : Windows 8.1 & Windows Server 2012 R2
SET "_win_os_version=8.1"
"%SystemRoot%\System32\cmd.exe" /x/d/c "echo. | call "%_win_os_version_INFO%" os get caption /format:value 2> NUL | call "%_win_os_version_FIND%" /IR /C:"Caption=.*Server.2008.R2.*" > NUL"
IF "%ERRORLEVEL%" == "0" (
    SET "_win_os_version=2012.R2"
    )
goto :_win_os_version_FOUND
:_win_os_version_check_6_3_DONE
:_win_os_version_check_6_4
if NOT "%_win_os_version_V_Mm%" == "6.4" ( goto :_win_os_version_check_6_4_DONE )
:: : Windows 10
SET "_win_os_version=10"
goto :_win_os_version_FOUND
:_win_os_version_check_6_4_DONE
:_win_os_version_check_10
if NOT "%_win_os_version_V_Mm%" == "10.0" ( goto :_win_os_version_check_10_0_DONE )
:: : Windows 10
SET "_win_os_version=10"
goto :_win_os_version_FOUND
:_win_os_version_check_10_0_DONE
:_win_os_version_check_11+
:: : Windows 11+
SET "_win_os_version=11+"
goto :_win_os_version_FOUND
:_win_os_version_check_11+_DONE
:_win_os_version_FIND_DONE
:_win_os_version_FOUND
::*::
:_win_os_version_RETURN
if EXIST "%_win_os_version_TEMPFILE%" ( erase "%_win_os_version_TEMPFILE%" > NUL )
REM call :_echo_DEBUG_KEY _win_os_version="%_win_os_version%"
REM call :_echo_DEBUG_KEY _win_os_version_N="%_win_os_version_N%"
::( endLocal
::  ( if NOT 1.0 == 1 (set "%_RETvar%=%_win_os_version%" & set "%_RETvar_N%=%_win_os_version_N%"
::          ) else (set "%_RETvar=%_win_os_version" & set "%_RETvar_N=%_win_os_version_N"
::              )
::      )
::@rem :::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
( endLocal
set %_RETvar%^=%_win_os_version%
if NOT "%_RETvar_N%"=="" (set %_RETvar_N%^=%_win_os_version_N%)
if NOT "%_RETvar_V%"=="" (set %_RETvar_V%^=%_win_os_version_V%)
if NOT "%_RETvar_V_Major%"=="" (set %_RETvar_V_Major%^=%_win_os_version_V_Major%)
if NOT "%_RETvar_V_minor%"=="" (set %_RETvar_V_minor%^=%_win_os_version_V_minor%)
if NOT "%_RETvar_V_build%"=="" (set %_RETvar_V_build%^=%_win_os_version_V_build%)
if NOT "%_RETvar_ARCH%"=="" (set %_RETvar_arch%^=%_win_os_version_ARCH%)
)
goto :EOF
::

::
:$$echo_noLF ( [ TEXT ] )
:$echo_noLF ( [ TEXT ] )
:_echo_noLF ( [ TEXT ] )
setLocal
if 01 == 1.0 ( goto :_echo_noLF_TCC )
:_echo_noLF_CMD
echo|set /p OUTPUT=%*
goto :_echo_noLF_RETURN
:_echo_noLF_TCC
echos %*
goto :_echo_noLF_RETURN
:_echo_noLF_RETURN
endLocal
goto :EOF
::

::
:$$echo_VERBOSE ( [ TEXT ... ] )
:: NOTE: __VERBOSE is GLOBAL to this function (and MUST be, because the shift command doesn't change subsequent %* uses {so, there is no way to pass vars into the function with arbitrary following TEXT})
if NOT DEFINED __VERBOSE ( goto :_echo_VERBOSE_RETURN )
echo %__ME%: %*
goto :_echo_VERBOSE_RETURN
:_echo_VERBOSE_RETURN
goto :EOF
::

::
:$$simple_dequote ( ref_RETURN ITEM )
:$simple_dequote ( ref_RETURN ITEM )
:_simple_dequote ( ref_RETURN ITEM )
:: strip outer double quotes from ITEM (NO attempt to check for or remove balanced quotes)
:: RETURN = dequoted ITEM
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_simple_dequote"
set "_RETvar=%~1"
set "_RETval=%~2"
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$length_of ( ref_RETURN ITEM )
:$length_of ( ref_RETURN ITEM )
:_length_of ( ref_RETURN ITEM )
:: determine length of ITEM
:: RETURN = length of ITEM
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_length_of"
set "_RETvar=%~1"
set "item=%~2"
set length=0
:_length_of_LOOP
if DEFINED item (
    set item=%item:~1%
    set /a length += 1
    goto :_length_of_LOOP
)
:_length_of_RETURN
set "_RETval=%length%"
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$trim ( ref_RETURN ITEM CHARSET )
:$trim ( ref_RETURN ITEM CHARSET )
:_trim ( ref_RETURN ITEM CHARSET )
:: trim characters from ITEM
:: RETURN == ITEM with CHARSET characters removed (from both sides)
:: NOTE: CHARSET defaults to "<SPACE>" if NULL/missing
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_trim"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if 1.0 == 01 (
    set _RETval=%@unquotes[%2]
    )
set "charset=%~3"
if 1.0 == 01 (
    set charset=%@unquotes[%3]
    )
if NOT DEFINED charset ( set "charset= " )
REM call :_echo_DEBUG_KEY _RETval/item="%_RETval%"
REM call :_echo_DEBUG_KEY charset="%charset%"
call :_ltrim _RETval "%_RETval%" "%charset%"
call :_rtrim _RETval "%_RETval%" "%charset%"
:_trim_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$ltrim ( ref_RETURN ITEM [CHARSET] )
:$ltrim ( ref_RETURN ITEM [CHARSET] )
:_ltrim ( ref_RETURN ITEM [CHARSET] )
:: trim characters in CHARSET from left-side of ITEM
:: RETURN = ITEM with leftmost CHARSET characters removed
:: NOTE: CHARSET defaults to "<SPACE>" if NULL/missing
:: refs: [Variable editing] http://ss64.com/nt/syntax-substring.html, [How to trim whitespace from a string] http://www.experts-exchange.com/OS/Microsoft_Operating_Systems/MS_DOS/Q_23816304.html
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_ltrim"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "item=%~2"
if 1.0 == 01 (
    set item=%@unquotes[%2]
    )
set "charset=%~3"
if 1.0 == 01 (
    set charset=%@unquotes[%3]
    )
if NOT DEFINED charset ( set "charset= " )
REM call :_echo_DEBUG_KEY *={%*}
REM call :_echo_DEBUG_KEY item="%item%"
REM call :_echo_DEBUG_KEY charset="%charset%"
:: change any internal double quotes to chr(255) (avoids syntax errors during the character comparison and removal process) [ NOTE: may have internal double quotes, so no outer quotes for set; this also creates a problem with internal ()'s if the set is enclosed in a block, so use a goto around it as needed]
if NOT DEFINED item ( goto :_ltrim_LOOP_ch )
set "item=%item:"=Â¸%"
set "charset=%charset:"=Â¸%"
set "chars=%charset%"
REM call :_echo_DEBUG_KEY LOOP.item="%item%"
REM call :_echo_DEBUG_KEY charset="%charset%"
REM call :_echo_DEBUG_KEY LOOP.chars="%chars%"
:_ltrim_LOOP_ch
set "ch="
if DEFINED chars ( set "ch=%chars:~0,1%" & set "chars=%chars:~1%" )
if NOT DEFINED ch ( goto :_ltrim_LOOP_DONE )
:_ltrim_LOOP_removal
if NOT DEFINED item ( goto :_ltrim_LOOP_DONE )
set "first_ch="
if DEFINED item (
    set "first_ch=%item:~0,1%"
    )
REM call :_echo_DEBUG_KEY LOOP.item="%item%"
REM call :_echo_DEBUG_KEY LOOP.item.first_ch="%first_ch%"
if /i "%first_ch%" == "%ch%" (
    set "item=%item:~1%"
    set "chars=%charset%"
    goto :_ltrim_LOOP_removal
    )
goto :_ltrim_LOOP_ch
:_ltrim_LOOP_DONE
:_ltrim_RETURN
if NOT DEFINED item ( goto :_ltrim_RETURN_translate_DONE )
:: return any double quotes to ITEM
set item=%item:Â¸=^"%
:_ltrim_RETURN_translate_DONE
set _RETval=%item%
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$translate_charset ( ref_RETURN ITEM CHARSET TRANS )
:$translate_charset ( ref_RETURN ITEM CHARSET TRANS )
:_translate_charset ( ref_RETURN ITEM CHARSET TRANS )
:: change all CHARSET characters to TRANS in ITEM
:: RETURN = ITEM with all characters in CHARSET changed to TRANS
:: NOTE: ITEM should have no internal double quotes; if present, double quotes are translated to single quotes(? TRUE, ?needed for CMD or TCC?) for the RETURN value
setLocal
set "__DEBUG_KEY=@1"
set "__MEfn=translate_charset"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "item=%~2"
set "charset_init=%~3"
set "trans=%~4"
REM call :_echo_DEBUG_KEY item="%item%"
REM call :_echo_DEBUG_KEY charset="%charset%"
REM call :_echo_DEBUG_KEY trans="%trans%"
:: change any internal double quotes to chr(255) (avoids syntax errors during the character comparison and removal process) [ NOTE: may have internal double quotes, so no outer quotes for set; this also creates a problem with internal ()'s if the set is enclosed in a block, so use a goto around it as needed]
if NOT DEFINED item ( goto :_translate_charset_LOOP_ch )
set "item=%item:^"=Â¸%"
::
:translate_charset_LOOP
set "item_dest="
:_translate_charset_LOOP_item
if NOT DEFINED item ( goto :_translate_charset_LOOP_item_DONE )
set "first_ch=%item:~0,1%"
set "item=%item:~1%"
set "charset=%charset_init%"
REM call :_echo_DEBUG_KEY charset="%charset%"
REM call :_echo_DEBUG_KEY first_ch="%first_ch%"
:_translate_charset_LOOP_ch
set "ch="
if DEFINED charset ( set "ch=%charset:~0,1%" & set "charset=%charset:~1%" )
if NOT DEFINED ch ( goto :_translate_charset_LOOP_ch_DONE )
REM call :_echo_DEBUG_KEY charset="%charset%"
REM call :_echo_DEBUG_KEY ch="%ch%"
:_translate_charset_LOOP_change
if NOT "%first_ch%" == "%ch%" ( goto :_translate_charset_LOOP_ch )
set "item_dest=%item_dest%%trans%"
goto :_translate_charset_LOOP_item
:_translate_charset_LOOP_ch_DONE
set "item_dest=%item_dest%%first_ch%"
goto :_translate_charset_LOOP_item
:_translate_charset_LOOP_item_DONE
set "item=%item_dest%"
REM call :_echo_DEBUG_KEY item="%item%"
:_translate_charset_LOOP_DONE
::
:_translate_charset_RETURN
:: return any double quotes to ITEM
set "item=%item:Â¸=^"%"
set "_RETval=%item%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$translate_charset_nocase ( ref_RETURN ITEM CHARSET TRANS )
:$translate_charset_nocase ( ref_RETURN ITEM CHARSET TRANS )
:_translate_charset_nocase ( ref_RETURN ITEM CHARSET TRANS )
:: change all CHARSET characters to TRANS in ITEM
:: RETURN = ITEM with all characters in CHARSET changed to TRANS
:: NOTE: ITEM should have no internal double quotes; if present, double quotes are translated to single quotes(? TRUE, ?needed for CMD or TCC?) for the RETURN value
setLocal
set "__DEBUG_KEY=@1"
set "__MEfn=translate_charset_nocase"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "item=%~2"
set "charset_init=%~3"
set "trans=%~4"
REM call :_echo_DEBUG_KEY item="%item%"
REM call :_echo_DEBUG_KEY charset="%charset%"
REM call :_echo_DEBUG_KEY trans="%trans%"
:: change any internal double quotes to chr(255) (avoids syntax errors during the character comparison and removal process) [ NOTE: may have internal double quotes, so no outer quotes for set; this also creates a problem with internal ()'s if the set is enclosed in a block, so use a goto around it as needed]
if NOT DEFINED item ( goto :_translate_charset_nocase_LOOP_ch )
set "item=%item:^"=Â¸%"
::
:translate_charset_LOOP
set "item_dest="
:_translate_charset_nocase_LOOP_item
if NOT DEFINED item ( goto :_translate_charset_nocase_LOOP_item_DONE )
set "first_ch=%item:~0,1%"
set "item=%item:~1%"
set "charset=%charset_init%"
REM call :_echo_DEBUG_KEY charset="%charset%"
REM call :_echo_DEBUG_KEY first_ch="%first_ch%"
:_translate_charset_nocase_LOOP_ch
set "ch="
if DEFINED charset ( set "ch=%charset:~0,1%" & set "charset=%charset:~1%" )
if NOT DEFINED ch ( goto :_translate_charset_nocase_LOOP_ch_DONE )
REM call :_echo_DEBUG_KEY charset="%charset%"
REM call :_echo_DEBUG_KEY ch="%ch%"
:_translate_charset_nocase_LOOP_change
if /i "%first_ch%" NEQ "%ch%" ( goto :_translate_charset_nocase_LOOP_ch )
set "item_dest=%item_dest%%trans%"
goto :_translate_charset_nocase_LOOP_item
:_translate_charset_nocase_LOOP_ch_DONE
set "item_dest=%item_dest%%first_ch%"
goto :_translate_charset_nocase_LOOP_item
:_translate_charset_nocase_LOOP_item_DONE
set "item=%item_dest%"
REM call :_echo_DEBUG_KEY item="%item%"
:_translate_charset_nocase_LOOP_DONE
::
:_translate_charset_nocase_RETURN
:: return any double quotes to ITEM
set "item=%item:Â¸=^"%"
set "_RETval=%item%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_matching_item ( ref_RETURN ITEM_X [ ITEMs ... ] )
:$is_matching_item ( ref_RETURN ITEM_X [ ITEMs ... ] )
:_is_matching_item ( ref_RETURN ITEM_X [ ITEMs ... ] )
:: determine if ITEM_X matched any of the ITEMs
:: RETURN == false/true (aka ITEM# [1+]) [ false == NULL, true == 1+ ]
:: NOTE: NULL items as "" or """" are supported
:: NOTE: ITEM comparisons are case-independent
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_matching_item"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
shift
set "item_x=%~1"
if "%item_x%" EQU """" ( set "item_x=" )
set "item_n=0"
REM call :_echo_DEBUG_KEY item_n="%item_n%"
:_is_matching_item_LOOP
shift
set item_raw=%1
REM call :_echo_DEBUG_KEY item_raw='%item_raw%'
if NOT DEFINED item_raw ( set "item_n=" & goto :_is_matching_item_LOOP_DONE )
set "item=%~1"
if "%item%" EQU """" ( set "item=" )
set /a item_n += 1 > nul
REM call :_echo_DEBUG_KEY item="%item%"
REM call :_echo_DEBUG_KEY item_n="%item_n%"
if DEFINED item_raw ( if /I "%item%" NEQ "%item_x%" ( goto :_is_matching_item_LOOP ) )
:_is_matching_item_LOOP_DONE
:_is_matching_item_RETURN
set "_RETval=%item_n%"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: done ]
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$remove_matching_item ( ref_RETURN ITEM_X [ ITEMs ... ] )
:$remove_matching_item ( ref_RETURN ITEM_X [ ITEMs ... ] )
:_remove_matching_item ( ref_RETURN ITEM_X [ ITEMs ... ] )
:: remove ITEM_X from list of ITEMs
:: RETURN == SET of ITEMs with ITEM_X removed (all occurrences)
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_remove_matching_item"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
shift
set "item_x=%~1"
if "%item_x%" EQU """" ( set "item_x=" )
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
REM call :_echo_DEBUG_KEY item_x="%item_x%"
:_remove_matching_item_LOOP
shift
set item_raw=%1
REM call :_echo_DEBUG_KEY item_raw="%item_raw%"
if NOT DEFINED item_raw ( goto :_remove_matching_item_LOOP_DONE )
set "item=%~1"
if "%item%" EQU """" ( set "item=" )
REM call :_echo_DEBUG_KEY item="%item%"
if /I "%item%" NEQ "%item_x%" ( call :_append_to_list _RETval "%item%" "%_RETval%" )
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
goto :_remove_matching_item_LOOP
:_remove_matching_item_LOOP_DONE
:_remove_matching_item_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$create_list_without_NULLs ( ref_RETURN [ ITEMs ... ] )
:$$create_list ( ref_RETURN [ ITEMs ... ] )
:$create_list ( ref_RETURN [ ITEMs ... ] )
:_create_list ( ref_RETURN [ ITEMs ... ] )
:: RETURN == LIST of ITEMs
setLocal
set "__DEBUG_KEY=@c"
set "__MEfn=_create_list"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:_create_list_LOOP
shift
set item_raw=%1
if NOT DEFINED item_raw ( goto :_create_list_LOOP_DONE )
set item=%~1
if "%item%" EQU """" ( set "item=" )
REM call :_echo_DEBUG_KEY item_N="%item%"
if NOT DEFINED _RETval (
    set "_RETval=%item%"
    ) else (
    set "_RETval=%_RETval%;%item%"
    )
goto :_create_list_LOOP
:_create_list_LOOP_DONE
:_create_list_RETURN
if NOT DEFINED _RETval ( set "_RETval=""" )
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$create_list_with_NULLs ( ref_RETURN [ ITEMs ... ] )
:$create_list_with_NULLs ( ref_RETURN [ ITEMs ... ] )
:_create_list_with_NULLs ( ref_RETURN [ ITEMs ... ] )
:: RETURN == LIST of ITEMs
setLocal
set "__DEBUG_KEY=@c"
set "__MEfn=_create_list_with_NULLs"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "last_item_NULL="
:_create_list_with_NULLs_LOOP
shift
set item_raw=%1
if NOT DEFINED item_raw ( goto :_create_list_with_NULLs_LOOP_DONE )
set "item=%~1"
if "%item%" EQU """" ( set "item=" )
REM call :_echo_DEBUG_KEY item_N="%item%"
if NOT DEFINED _RETval (
    if DEFINED last_item_NULL (
        set "_RETval=%_RETval%;%item%"
        ) else (
        set "_RETval=%item%"
        )
    ) else (
    set "_RETval=%_RETval%;%item%"
    )
set "last_item_NULL="
if NOT DEFINED item ( set "last_item_NULL=1" )
goto :_create_list_with_NULLs_LOOP
:_create_list_with_NULLs_LOOP_DONE
:_create_list_with_NULLs_RETURN
if NOT DEFINED _RETval ( set "_RETval=""" )
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$list_to_items ( ref_RETURN LIST )
:: return separated LIST elements
:: RETURN == separated LIST ITEM elements
setLocal
set "_RETval="
set "_RETvar=%~1"
set "list=%~2"
if NOT DEFINED list ( goto :_list_to_items_DONE )
call :_first_of arg "%list%"
call :_remove_first list "%list%"
call :$$count_of_items N %arg%
if NOT "%N%"=="1" set arg="%arg%"
set _RETval=%arg%
:_list_to_items_LOOP
if NOT DEFINED list ( goto :_list_to_items_DONE )
call :_first_of arg "%list%"
call :_remove_first list "%list%"
call :$$count_of_items N %arg%
if NOT "%N%"=="1" set arg="%arg%"
set _RETval=%_RETval% %arg%
goto :_list_to_items_LOOP
:_list_to_items_DONE
:_list_to_items_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$count_of ( ref_RETURN [ LIST ] )
:: return number of ITEMs within LIST
:: RETURN == number of ITEM(s) within LIST
setLocal
set "_RETval=0"
set "_RETvar=%~1"
set "list=%~2"
call :$$count_of_items _RETval "%list:;=" "%"
:$$count_of_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$count_of_items ( ref_RETURN [ ITEMs ... ] )
:: return separated LIST elements
:: RETURN == number of ITEM(s)
setLocal
set "_RETval=0"
set "_RETvar=%~1"
:$$count_of_items_LOOP
shift
set item_raw=%1
if NOT DEFINED item_raw ( goto :$$count_of_items_LOOP_DONE )
set /a _RETval += 1
goto :$$count_of_items_LOOP
:$$count_of_items_LOOP_DONE
:$$count_of_items_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_in_list ( ref_RETURN ITEM LIST )
:$is_in_list ( ref_RETURN ITEM LIST )
:_is_in_list ( ref_RETURN ITEM LIST )
:: determine if ITEM is within LIST
:: RETURN == (BOOLEAN: undef/1+ (ITEM# [1+])) whether ITEM is contained within the LIST
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_in_list"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set _RETvar=%~1
set "list=%~3"
set "item=%~2"
REM call :_echo_DEBUG_KEY list="%list%"
REM call :_echo_DEBUG_KEY item="%item%"
if DEFINED list ( call :_is_matching_item _RETval "%item%" "%list:;=" "%" )
:_is_in_list_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$prepend_to_list ( ref_RETURN ITEM LIST )
:$prepend_to_list ( ref_RETURN ITEM LIST )
:_prepend_to_list ( ref_RETURN ITEM LIST )
:: RETURN == LIST with ITEM prepended
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_prepend_to_list"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set _RETvar=%~1
set list=%~3
set item=%~2
if "%item%" EQU """" ( set "item=" )
set "_RETval=%item%"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
REM call :_echo_DEBUG_KEY list="%list%"
REM call :_echo_DEBUG_KEY item="%item%"
if NOT DEFINED list ( goto :_prepend_to_list_RETURN )
if "%list%" EQU """" ( set "list=" )
set "_RETval=%item%;%list%"
REM call :_echo_DEBUG_KEY 2
:_prepend_to_list_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
if NOT DEFINED _RETval ( set "_RETval=""" )
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$append_to_list ( ref_RETURN ITEM LIST )
:$append_to_list ( ref_RETURN ITEM LIST )
:_append_to_list ( ref_RETURN ITEM LIST )
:: RETURN == LIST with ITEM appended
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_append_to_list"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set _RETvar=%~1
set "list=%~3"
set "item=%~2"
if "%item%" EQU """" ( set "item=" )
set "_RETval=%item%"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY list="%list%"
REM call :_echo_DEBUG_KEY item="%item%"
if NOT DEFINED list ( goto :_append_to_list_RETURN )
if "%list%" EQU """" ( set "list=" )
set "_RETval=%list%;%item%"
:_append_to_list_RETURN
if NOT DEFINED _RETval ( set "_RETval=""" )
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$prepend_to_set ( ref_RETURN ITEM SET )
:$prepend_to_set ( ref_RETURN ITEM SET )
:_prepend_to_set ( ref_RETURN ITEM SET )
:: RETURN == SET/LIST with ITEM prepended (if not already in SET/LIST)
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_prepend_to_set"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set _RETvar=%~1
set list=%~3
set item=%~2
set _RETval=%list%
REM call :_echo_DEBUG_KEY list="%list%"
REM call :_echo_DEBUG_KEY item="%item%"
call :_is_in_list IN_list "%item%" "%list%"
REM call :_echo_DEBUG_KEY 1
if NOT DEFINED IN_list ( call :_prepend_to_list _RETval "%item%" "%list%" )
:_prepend_to_set_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$append_to_set ( ref_RETURN ITEM SET )
:$append_to_set ( ref_RETURN ITEM SET )
:_append_to_set ( ref_RETURN ITEM SET )
:: RETURN == SET/LIST with ITEM appended (if not already in SET/LIST)
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_append_to_set"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set _RETvar=%~1
set "list=%~3"
set "item=%~2"
set "_RETval=%list%"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY list="%list%"
REM call :_echo_DEBUG_KEY item="%item%"
call :_is_in_list IN_list "%item%" "%list%"
REM call :_echo_DEBUG_KEY IN_list="%IN_list%"
if NOT DEFINED IN_list ( call :_append_to_list _RETval "%item%" "%list%" )
:_append_to_set_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$prepend_to_pathlist ( ref_RETURN ITEM PATHLIST )
:$prepend_to_pathlist ( ref_RETURN ITEM PATHLIST )
:_prepend_to_pathlist ( ref_RETURN ITEM PATHLIST )
:: NOTE: PATHLIST is treated as a SET of PATHs
:: RETURN == PATHLIST with ITEM prepended (if not already in PATHLIST)
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_prepend_to_pathlist"
set _RETvar=%~1
set list=%~3
set item=%~2
if "%item%" EQU """" ( set "item=" )
call :_rtrim item "%item%" "\"
set _RETval=%list%
if DEFINED item ( call :_prepend_to_set _RETval "%item%" "%list%" )
:_prepend_to_pathlist_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$append_to_pathlist ( ref_RETURN ITEM PATHLIST )
:$append_to_pathlist ( ref_RETURN ITEM PATHLIST )
:_append_to_pathlist ( ref_RETURN ITEM PATHLIST )
:: NOTE: PATHLIST is treated as a SET of PATHs
:: RETURN == PATHLIST with ITEM appended (if not already in PATHLIST)
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_append_to_pathlist"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set _RETvar=%~1
set "list=%~3"
set "item=%~2"
if "%item%" EQU """" ( set "item=" )
call :_rtrim item "%item%" "\"
set "_RETval=%list%"
REM call :_echo_DEBUG_KEY item="%item%"
REM call :_echo_DEBUG_KEY list="%list%"
if DEFINED item ( call :_append_to_set _RETval "%item%" "%list%" )
:_append_to_pathlist_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$remove_from_list ( ref_RETURN ITEM LIST )
:$remove_from_list ( ref_RETURN ITEM LIST )
:_remove_from_list ( ref_RETURN ITEM LIST )
:: RETURN == LIST with ITEM removed (all occurrences)
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_remove_from_list"
set "_RETval="
set _RETvar=%~1
set "list=%~3"
set "item=%~2"
if DEFINED list ( call :_remove_matching_item _RETval "%item%" "%list:;=" "%" )
:_remove_from_list_RETURN
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$create_pathlist ( ref_RETURN [ ITEMs ... ] )
:$create_pathlist ( ref_RETURN [ ITEMs ... ] )
:_create_pathlist ( ref_RETURN [ ITEMs ... ] )
:: NOTE: PATHLIST is a SET of PATHs (no NULL PATHs; PATHs are normalized ITEMs [no trailing backslashes] )
:: RETURN == PATHLIST of PATHs
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_create_pathlist"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval="
:_create_pathlist_LOOP
shift
set item_raw=%1
if NOT DEFINED item_raw ( goto :_create_pathlist_LOOP_DONE )
set "item=%~1"
if "%item%" EQU """" ( set "item=" )
call :_rtrim item "%item%" "\"
call :_append_to_pathlist _RETval "%item%" "%_RETval%"
goto :_create_pathlist_LOOP
:_create_pathlist_LOOP_DONE
:_create_pathlist_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$create_set ( ref_RETURN [ ITEMs ... ] )
:$create_set ( ref_RETURN [ ITEMs ... ] )
:_create_set ( ref_RETURN [ ITEMs ... ] )
:: NOTE: SET is a LIST of ITEMs (with no repeated ITEMs)
:: RETURN == SET of ITEMs
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_create_set"
set "_RETvar=%~1"
set "_RETval="
:_create_set_LOOP
shift
set item_raw=%1
if NOT DEFINED item_raw ( goto :_create_set_LOOP_DONE )
set "item=%~1"
if "%item%" EQU """" ( set "item=" )
call :_append_to_set _RETval "%item%" "%_RETval%"
goto :_create_set_LOOP
:_create_set_LOOP_DONE
:_create_set_RETURN
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$first_of ( ref_RETURN LIST )
:$first_of ( ref_RETURN LIST )
:_first_of ( ref_RETURN LIST )
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_first_of"
set "_RETval="
set _RETvar=%~1
set "list=%~2"
if DEFINED list ( call :_first_of_items _RETval "%list:;=" "%" )
:_first_of_RETURN
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$first_of_items ( ref_RETURN [ ITEMs ... ] )
:$first_of_items ( ref_RETURN [ ITEMs ... ] )
:_first_of_items ( ref_RETURN [ ITEMs ... ] )
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_first_of_items"
set _RETvar=%~1
set "item=%~2"
if "%item%" == """" ( set "item=" )
:_first_of_items_RETURN
set "_RETval=%item%"
::endLocal & if NOT 01 == 1.0 (set "%_RETvar%=%_RETval%") else (set "%_RETvar=%_RETval")
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$remove_first_item ( ref_RETURN [ ITEMs ... ] )
:$remove_first_item ( ref_RETURN [ ITEMs ... ] )
:_remove_first_item ( ref_RETURN [ ITEMs ... ] )
:: RETURN == LIST of all ITEMs excepting the initial ITEM
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_remove_first_item"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
shift
:_remove_first_item_LOOP
shift
set item_raw=%1
REM call :_echo_DEBUG_KEY item_raw="%item_raw%"
if NOT DEFINED item_raw ( goto :_remove_first_item_LOOP_DONE )
set "item=%~1"
if "%item%" EQU """" ( set "item=" )
REM call :_echo_DEBUG_KEY item="%item%"
call :_append_to_list _RETval "%item%" "%_RETval%"
goto :_remove_first_item_LOOP
:_remove_first_item_LOOP_DONE
:_remove_first_item_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$remove_first ( ref_RETURN LIST )
:$remove_first ( ref_RETURN LIST )
:_remove_first ( ref_RETURN LIST )
:: RETURN == LIST with first ITEM removed
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_remove_first"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "list=%~2"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY list="%list%"
if DEFINED list ( call :_remove_first_item _RETval "%list:;=" "%" )
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$first_list_match ( ref_RETURN LIST1 LIST2 )
:$first_list_match ( ref_RETURN LIST1 LIST2 )
:_first_list_match ( ref_RETURN LIST1 LIST2 )
:: RETURN == first ITEM in LIST1 which is also contained in LIST2
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_first_list_match"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "list1=%~2"
set "list2=%~3"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY list1="%list1%"
REM call :_echo_DEBUG_KEY list2="%list2%"
:_first_list_match_LOOP
if NOT DEFINED list1 ( goto :_first_list_match_RETURN )
call :_first_of item "%list1%"
call :_remove_first list1 "%list1%"
REM call :_echo_DEBUG_KEY item="%item%"
REM call :_echo_DEBUG_KEY list="%list%"
call :_is_in_list IS_match "%item%" "%list2%"
if NOT DEFINED IS_match ( goto :_first_list_match_LOOP )
set "_RETval=%item%"
:_first_list_match_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$path_in_pathlist ( ref_RETURN FILENAME PATHLIST )
:$path_in_pathlist ( ref_RETURN FILENAME PATHLIST )
:_path_in_pathlist ( ref_RETURN FILENAME PATHLIST )
:: NOTE: FILENAME should be a simple filename, not a directory or filename with leading directory prefix. CMD will match these more complex paths, but TCC will not.
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_path_in_pathlist"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "pathlist=%~3"
set "PATH=%pathlist%"
REM call :_echo_DEBUG_KEY ref_RETURN="%~1"
REM call :_echo_DEBUG_KEY filename="%~2"
REM call :_echo_DEBUG_KEY pathlist="%pathlist%"
::call :_path_of_file_in_paths _RETval "%~2" "%pathlist:;=" "%"
set "_RETval=%~$PATH:2"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
:_path_in_pathlist_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$path_in_PATH ( ref_RETURN FILENAME )
:$path_in_PATH ( ref_RETURN FILENAME )
:_path_in_PATH ( ref_RETURN FILENAME )
:: NOTE: FILENAME should be a simple filename, not a directory or filename with leading directory prefix. CMD will match these more complex paths, but TCC will not.
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_path_in_PATH"
set "_RETvar=%~1"
call :_path_in_pathlist _RETval "%~2" ".;%PATH%"  &:: the current working directory is implied in %PATH% (and searched 1st); make this explicit for this search
:_path_in_PATH_RETURN
endLocal & set "%~1=%_RETval%"
goto :EOF
::

::
:$$path_of_file_in_pathlist ( ref_RETURN FILENAME PATHLIST [EXTENSIONLIST] )
:$path_of_file_in_pathlist ( ref_RETURN FILENAME PATHLIST [EXTENSIONLIST] )
:_path_of_file_in_pathlist ( ref_RETURN FILENAME PATHLIST [EXTENSIONLIST] )
:: NOTE: FILENAME should be a simple filename, not a directory or filename with leading directory prefix. CMD will match these more complex paths, but TCC will not.
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_path_of_file_in_pathlist"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
set "extensionList=%~4"
REM call :_echo_DEBUG_KEY _RETvar="%~1"
REM call :_echo_DEBUG_KEY filename="%~2"
REM call :_echo_DEBUG_KEY pathlist="%~3"
REM call :_echo_DEBUG_KEY extensionList="%extensionList%"
if NOT DEFINED extensionList ( goto :_path_of_file_in_pathlist_EXTS_NULL )
:_path_of_file_in_pathlist_EXTS
REM echo call :_path_of_file_in_pathlist_with_extensions _RETval "%~2" "%~3" "%extensionList:;=" "%"
call :_path_of_file_in_pathlist_with_extensions _RETval "%~2" "%~3" "%extensionList:;=" "%"
goto :_path_of_file_in_pathlist_DONE
:_path_of_file_in_pathlist_EXTS_NULL
call :_path_in_pathlist _RETval "%~2" "%~3"
:_path_of_file_in_pathlist_DONE
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
:_path_of_file_in_pathlist_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$path_of_file_in_pathlist_with_extensions ( ref_RETURN FILENAME PATHLIST [[EXTENSION1] [EXTENSION2] ...]  )
:$path_of_file_in_pathlist_with_extensions ( ref_RETURN FILENAME PATHLIST [[EXTENSION1] [EXTENSION2] ...]  )
:_path_of_file_in_pathlist_with_extensions ( ref_RETURN FILENAME PATHLIST [[EXTENSION1] [EXTENSION2] ...]  )
:: NOTE: FILENAME should be a simple filename, not a directory or filename with leading directory prefix. CMD will match these more complex paths, but TCC will not.
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_path_of_file_in_pathlist_with_extensions"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set _RETvar=%~1
shift
set "_f=%~1"
shift
set "pathlist=%~1"
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY filename="%_f%"
REM call :_echo_DEBUG_KEY pathlist="%pathlist%"
set "_RETval_level="
:_path_of_file_in_pathlist_with_extensions_LOOP
shift
REM call :_echo_DEBUG_KEY ext_N="%~1"
set item_raw=%1
if NOT defined item_raw ( goto :_path_of_file_in_pathlist_with_extensions_RETURN )
call :_path_in_pathlist _f_path "%_f%%~1" "%pathlist%"
if "%_f_path%" EQU "" ( goto :_path_of_file_in_pathlist_with_extensions_LOOP )
REM call :_echo_DEBUG_KEY _f_path="%_f_path%"
call :_dir_of _f_dir "%_f_path%"
REM call :_echo_DEBUG_KEY _f_path="%_f_path%"
call :_is_in_list _f_level "%_f_dir%" "%pathlist%"
::if DEFINED _f_level ( if "%_RETval_level%" EQU "" ( set "_RETval_level=%_f_level%" & set "_RETval=%_f_path%" ) )
::if DEFINED _f_level ( if %_f_level%0 LSS %_RETval_level%0 ( set "_RETval_level=%_f_level%" & set "_RETval=%_f_path%" ) )
if NOT defined _RETval_level ( set "_RETval_level=%_f_level%" & set "_RETval=%_f_path%" )
if %_f_level%0 LSS %_RETval_level%0 ( set "_RETval_level=%_f_level%" & set "_RETval=%_f_path%" )
REM call :_echo_DEBUG_KEY _f_level="%_f_level%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
REM call :_echo_DEBUG_KEY _RETval_level="%_RETval_level%"
goto :_path_of_file_in_pathlist_with_extensions_LOOP
:_path_of_file_in_pathlist_with_extensions_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$path_of_file_in_PATH ( ref_RETURN FILENAME EXTENSIONLIST )
:$path_of_file_in_PATH ( ref_RETURN FILENAME EXTENSIONLIST )
:_path_of_file_in_PATH ( ref_RETURN FILENAME EXTENSIONLIST )
:: NOTE: FILENAME should be a simple filename, not a directory or filename with leading directory prefix. CMD will match these more complex paths, but TCC will not.
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_path_of_file_in_PATH"
call :_path_of_file_in_pathlist _RETval "%~2" "%PATH%" "%~3"
:_path_of_file_in_PATH_RETURN
endLocal & set "%~1=%_RETval%"
goto :EOF
::

::
:$$path_of_item_in_pathlist ( ref_RETURN ITEMNAME PATHLIST )
:$path_of_item_in_pathlist ( ref_RETURN ITEMNAME PATHLIST )
:_path_of_item_in_pathlist ( ref_RETURN ITEMNAME PATHLIST )
:: RETURN == PATH of first ITEMNAME found within PATHLIST (NULL if not found)
:: NOTE: ITEMNAME can be a simple filename, a path, or filename with leading prefix
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_path_of_item_in_pathlist"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "item=%~2"
set "pathlist=%~3"
set "_RETval="
REM call :_echo_DEBUG_KEY ref_RETURN="%_RETvar%"
REM call :_echo_DEBUG_KEY itemname="%item%"
call :_path_of_item_in_paths _RETval "%item%" "%pathlist:;=" "%"
:_path_of_file_in_paths_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$path_of_item_in_paths ( ref_RETURN ITEMNAME PATH1 [[PATH2] ...] )
:$path_of_item_in_paths ( ref_RETURN ITEMNAME PATH1 [[PATH2] ...] )
:_path_of_item_in_paths ( ref_RETURN ITEMNAME PATH1 [[PATH2] ...] )
:: RETURN == PATH of ITEMNAME from within PATHs (NULL if not found)
:: NOTE: ITEMNAME can be a simple filename, a path, or filename with leading partial prefix
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_path_of_item_in_paths"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
shift
set "item=%~1"
set "_RETval="
REM call :_echo_DEBUG_KEY ref_RETURN="%_RETvar%"
REM call :_echo_DEBUG_KEY itemname="%item%"
:_path_of_item_in_paths_LOOP
shift
REM call :_echo_DEBUG_KEY path_N="%~1"
set item_raw=%1
if NOT defined item_raw ( goto :_path_of_item_in_paths_RETURN )
if EXIST "%~1\%item%" ( set "_RETval=%~1\%item%" & goto :_path_of_item_in_paths_RETURN )
goto :_path_of_item_in_paths_LOOP
:_path_of_item_in_paths_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$fullname_of ( ref_RETURN PATH )
:$fullname_of ( ref_RETURN PATH )
:_fullname_of ( ref_RETURN PATH )
:$$FQ_name_of
:$$FQ_fullname_of
:$$fully_qualified_form_of
:$FQ_name_of
:$FQ_fullname_of
:$fully_qualified_form_of
:_FQ_name_of
:_FQ_fullname_of
:_fully_qualified_form_of
:: RETURN == fully qualified name of PATH
:: ToDO: ? pull out _fullname_of to separate function in keeping with _drive_of / _FQ_drive_of and _dir_of / _FQ_dir_of
:: NOTE: special processing to deal correctly with the case of "<DRIVE>:" ("<DRIVE>:" == "<DRIVE>:" == "<DRIVE>:.", NOT "<DRIVE>:.")
:: NOTE: _fullname_of("") == ""
:: NOTE: _fullname_of("\\") == _fullname_of("\") == _fullname_of("\.") == "<CURRENTDRIVE>:\"
:: NOTE: _fullname_of("c:") == _fullname_of("c:.")
:: NOTE: special processing is needed to deal with the fact that TCC acts out with almost unsuppressible errors for inaccessible and UNC PATHs [which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_fullname_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
REM call :_echo_DEBUG_KEY 2="%~2"
:: avoid TCC path parsing errors for null strings
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_fullname_of_RETURN )
if "%_RETval%" == "\\" ( set "_RETval=\" )
::
::?:call :_drive_of drive "%~2"
REM call :_echo_DEBUG_KEY drive="%drive%"
::?:if /i "%drive%" == "%~2" ( set "_RETval=%~2" & goto :_fullname_of_RETURN )
call :_rewrite_path_to_FQ_local _RETval drive "%_RETval%"
if NOT DEFINED drive ( set "drive=%SYSTEMDRIVE%" )
if NOT DEFINED drive ( set "drive=%SYSTEMROOT:~0,2%" )
if NOT DEFINED drive ( set "drive=%~d0" )
REM call :_echo_DEBUG_KEY drive="%drive%"
REM call :_echo_DEBUG_KEY _RETval_local="%_RETval%"
call :_param_tilde_PNX _RETval "%_RETval%"
REM call :_echo_DEBUG_KEY _RETval_PNX="%_RETval%"
set "_RETval=%drive%%_RETval%"
REM call :_echo_DEBUG_KEY _RETval_DR="%_RETval%"
::?:call :_rtrim _RETval "%_RETval%" "\\"
:_fullname_of_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$shortname_of ( ref_RETURN PATH )
:$shortname_of ( ref_RETURN PATH )
:_shortname_of ( ref_RETURN PATH )
:: RETURN == fully qualified short name of PATH
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_shortname_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set _RETvar=%~1
call :_param_tilde_SF _RETval "%~2"
call :_FQ_fullname_of _RETval "%_RETval%"
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$dir_of ( ref_RETURN PATH )
:$dir_of ( ref_RETURN PATH )
:_dir_of ( ref_RETURN PATH )
:: RETURN == directory of PATH
:: NOTE: uses the PATH as is without changing it to fully qualified form
:: NOTE: special processing to deal correctly with the case of "<DRIVE>:" ("<DRIVE>:" == "<DRIVE>:."; "DRIVE:\" == "<DRIVE>:\.")
:: NOTE: _dir_of("") == ""
:: NOTE: _dir_of("\\") == _dir_of("\") == "\"
:: NOTE: _dir_of("c:") == _dir_of("c:.")
:: NOTE: _dir_of("c:\") == _dir_of("c:\.") == "\"
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_dir_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: avoid TCC path parsing errors for null strings
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_dir_of_RETURN )
if "%_RETval%" == "\\" ( set "_RETval=\" )
::
::?:call :_drive_of drive "%~2"
::?:call :_echo_DEBUG_KEY drive="%drive%"
::?:if /i "%drive%" == "%~2" ( set "_RETval=%~2" & goto :_dir_of_RETURN )
call :_rewrite_path_to_FQ_local _path drive "%_RETval%"
call :_param_tilde_P _RETval "%_path%"
::?:call :_param_tilde_N NAME "%_path%"
REM call :_echo_DEBUG_KEY _P="%_RETval%"
call :_rtrim _RETval "%_RETval%" "\"
::?:if NOT DEFINED _RETval if DEFINED NAME (set _RETval=\)
if NOT DEFINED _RETval (set _RETval=\)
::set "_RETval=%drive%%_RETval%"
:_dir_of_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$FQ_dir_of ( ref_RETURN PATH )
:$FQ_dir_of ( ref_RETURN PATH )
:_FQ_dir_of ( ref_RETURN PATH )
:: RETURN == fully qualified directory of PATH
:: NOTE: _FQ_dir_of("") == ""
:: NOTE: _FQ_dir_of("\\") == _FQ_dir_of("\")
:: NOTE: _FQ_dir_of("c:") == _FQ_dir_of("c:.")
:: NOTE: _FQ_dir_of("c:\") == _FQ_dir_of("c:\.") == "c:\"
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_FQ_dir_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: avoid TCC path parsing errors for null strings
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_FQ_dir_of_RETURN )
if "%_RETval%" == "\\" ( set "_RETval=\" )
call :_rewrite_path_to_FQ_local _RETval drive "%_RETval%"
::?:call :_dir_of _RETval "%_RETval%"
if NOT DEFINED _RETval ( goto :_FQ_dir_of_RETURN )
call :_param_tilde_P _RETval "%_RETval%"
REM call :_echo_DEBUG_KEY _P="%_RETval%"
call :_rtrim _RETval "%_RETval%" "\"
if NOT DEFINED _RETval ( set "_RETval=\" )
:_FQ_dir_of_DONE
if NOT DEFINED drive ( set "drive=%SYSTEMDRIVE%" )
if NOT DEFINED drive ( set "drive=%SYSTEMROOT:~0,2%" )
if NOT DEFINED drive ( set "drive=%~d0" )
REM call :_echo_DEBUG_KEY drive="%drive%"
set "_RETval=%drive%%_RETval%"
:_FQ_dir_of_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$extension_of ( ref_RETURN PATH )
:$extension_of ( ref_RETURN PATH )
:_extension_of ( ref_RETURN PATH )
:: RETURN == extension of PATH
:: NOTE: _extension_of "" == "" ; _extension_of "c:" == "" ; _extension_of "\\" == "" _extension_of "\" == ""
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_extension_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: avoid TCC path parsing errors for null strings
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_extension_of_RETURN )
::
call :_rewrite_path_to_FQ_local _RETval _ "%_RETval%"
call :_param_tilde_X _RETval "%_RETval%"
call :_rtrim _RETval "%_RETval%" "\"
:_extension_of_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$param_tilde_PNX ( ref_RETURN PATH )
:$param_tilde_PNX ( ref_RETURN PATH )
:_param_tilde_PNX ( ref_RETURN PATH )
:: NOTE: for TCC, assume that PATH is on (or has been forced onto) an accessible drive and not a UNC pathname [necessary to avoid insuppressible TCC parsing errors; which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: RETURN == path, name, and extension of PATH
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_param_tilde_PNX"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_param_tilde_PNX_RETURN )
set "_RETval=%~pnx2"
:_param_tilde_PNX_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$param_tilde_P ( ref_RETURN PATH )
:$param_tilde_P ( ref_RETURN PATH )
:_param_tilde_P ( ref_RETURN PATH )
:: NOTE: for TCC, assume that PATH is on (or has been forced onto) an accessible drive and not a UNC pathname [necessary to avoid insuppressible TCC parsing errors; which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: RETURN == directory of PATH
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_param_tilde_P"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_param_tilde_P_RETURN )
set "_RETval=%~p2"
REM call :_echo_DEBUG_KEY 1="%~1"
REM call :_echo_DEBUG_KEY 2="%~2"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
:_param_tilde_P_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$param_tilde_NX ( ref_RETURN PATH )
:$param_tilde_NX ( ref_RETURN PATH )
:_param_tilde_NX ( ref_RETURN PATH )
:: NOTE: for TCC, assume that PATH is on an accessible drive and not a UNC pathname [necessary to avoid insuppressible TCC parsing errors; which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: RETURN == name & extension of PATH
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_param_tilde_NX"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_param_tilde_NX_RETURN )
set "_RETval=%~nx2"
:_param_tilde_NX_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$param_tilde_X ( ref_RETURN PATH )
:$param_tilde_X ( ref_RETURN PATH )
:_param_tilde_X ( ref_RETURN PATH )
:: NOTE: for TCC, assume that PATH is on an accessible drive and not a UNC pathname [necessary to avoid insuppressible TCC parsing errors; which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: RETURN == extension of PATH
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_param_tilde_X"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_param_tilde_X_RETURN )
set "_RETval=%~x2"
:_param_tilde_X_RETURN
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$param_tilde_SF ( ref_RETURN PATH )
:$param_tilde_SF ( ref_RETURN PATH )
:_param_tilde_SF ( ref_RETURN PATH )
:: NOTE: for TCC, assume that PATH is on (or has been forced onto) an accessible drive and not a UNC pathname [necessary to avoid insuppressible TCC parsing errors; which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: RETURN == short full name of PATH [ PATH is either absolute or assumed to be relative to %CD%]
:: ref: [Bug and workaround in %~sf0 ] https://groups.google.com/d/topic/alt.msdos.batch.nt/CrLJbBzgdkk/discussion
:: ref: [Discussion of bug in %~s0 syntax ] https://groups.google.com/d/topic/alt.msdos.batch.nt/TkUsCQuL_bg/discussion
:: ref: [CMD percent-tilde Syntax] http://ss64.com/nt/syntax-args.html @@ http://www.webcitation.org/67qH4Ri09
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_param_tilde_SF"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_param_tilde_SF_RETURN )
set "_RETval=%~sf2"
:_param_tilde_SF_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$param_tilde_A ( ref_RETURN PATH )
:$param_tilde_A ( ref_RETURN PATH )
:_param_tilde_A ( ref_RETURN PATH )
:: NOTE: for TCC, assume that PATH is on (or has been forced onto) an accessible drive and not a UNC pathname [necessary to avoid insuppressible TCC parsing errors; which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: RETURN == attributes of full name of PATH [ PATH is either absolute or assumed to be relative to %CD%]
:: ref: [CMD percent-tilde Syntax] http://ss64.com/nt/syntax-args.html @@ http://www.webcitation.org/67qH4Ri09
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_param_tilde_A"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_param_tilde_SF_RETURN )
set "_RETval=%~a2"
:_param_tilde_A_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$param_tilde_DPNX ( ref_RETURN PATH )
:$param_tilde_DPNX ( ref_RETURN PATH )
:_param_tilde_DPNX ( ref_RETURN PATH )
:: NOTE: for TCC, assume that PATH is on (or has been forced onto) an accessible drive and not a UNC pathname [necessary to avoid insuppressible TCC parsing errors; which is "WAD" per developer [meh, see ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://www.webcitation.org/63ua1bpOk]]
:: RETURN == drive, path, name, and extension of PATH
setLocal
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_param_tilde_PNX_RETURN )
set "_RETval=%~dpnx2"
:_param_tilde_PNX_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$attributes_of ( ref_RETURN PATH )
:$attributes_of ( ref_RETURN PATH )
:_attributes_of ( ref_RETURN PATH )
:: RETURN == attribute string for PATH ("", if PATH not accessible)
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_attributes_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set _RETvar=%~1
:: TCC can't handle nonexistent PATHs (especially non-existent drives)
if NOT EXIST "%~2" ( goto :_attributes_of_RETURN )
set "_RETval=%~a2"
:_attributes_of_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$size_of ( ref_RETURN FILE )
:$size_of ( ref_RETURN FILE )
:_size_of ( ref_RETURN FILE )
:: RETURN == size of FILE
:: NOTE: _size_of(FILE; FILE not accessible) == ""
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_size_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: TCC can't handle nonexistent PATHs (especially non-existent drives)
if NOT EXIST "%~2" ( goto :_size_of_RETURN )
set "_RETval=%~z2"
:_size_of_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$filetime_of ( ref_RETURN FILE )
:$filetime_of ( ref_RETURN FILE )
:_filetime_of ( ref_RETURN FILE )
:: RETURN == file time of FILE ("", if FILE is missing)
:: NOTE: file time is returned in "YYYY-MM-DD.HHmm" format [this format is comparable using usual string comparisons for time ordering; and has no illegal file characters, allowing use in a filename]
:: NOTE: _filetime_of(PATH; PATH not accessible) == ""
:: ToDO: check assumptions regarding leading zeros in "~tN" substitution for all time sections
:: ToDO: FIX: time changes by 60 minutes with change in DST ... leave this as LOCAL time ... create _filetime_GMT_of()
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_filetime_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
if NOT EXIST "%~2" ( goto :_filetime_of_RETURN )
set "_RETval=%~t2" &:: format is 'MM/DD/YYYY HH:mm A/PM' [eg, '08/19/2018 12:47 PM']
if NOT DEFINED _RETval ( goto :_filetime_of_RETURN )
:: transform to comparable strings
if 1.0 == 1 ( goto :_filetime_of_TCC_transform ) &:: TCC uses a different format for ~tN time/date values
:_filetime_of_CMD_transform
set "year=%_RETval:~6,4%"
set "month=%_RETval:~0,2%"
set "day=%_RETval:~3,2%"
set "hour=%_RETval:~11,2%"
set "minute=%_RETval:~14,2%"
set "ampm=%_RETval:~17,1%"
if "%hour%" == "12" ( set "hour=00" )
if /i "%ampm%" == "p" (
    rem numbers with leading 0's are seen as octal numbers by SET; correct 08 and 09
    if "%hour%"=="08" set hour=8
    if "%hour%"=="09" set hour=9
    set /a hour += 12
    )
goto :_filetime_of_SET_RETval
:_filetime_of_TCC_transform
set _RETval=%@filedate["%~2",w,4] %@filetime["%~2"]
set "year=%_RETval:~0,4%"
set "month=%_RETval:~5,2%"
set "day=%_RETval:~8,2%"
set "hour=%_RETval:~11,2%"
set "minute=%_RETval:~14,2%"
if "%hour%" == "12" ( set "hour=00" )
goto :_filetime_of_SET_RETval
:_filetime_of_SET_RETval
set "_RETval=%year%-%month%-%day%.%hour%%minute%"
:_filetime_of_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
REM call :_echo_DEBUG_KEY ~t2="%~t2"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_archive ( ref_RETURN PATH )
:$is_archive ( ref_RETURN PATH )
:_is_archive ( ref_RETURN PATH )
:: RETURN == (BOOLEAN as undef/1) whether PATH is a directory
:: NOTE: ref: http://stackoverflow.com/a/3728742/43774 from http://stackoverflow.com/questions/138981/how-do-i-test-if-a-file-is-a-directory-in-a-batch-script
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_archive"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: TCC can't handle nonexistent PATHs (especially non-existent drives)
if NOT EXIST "%~2" ( goto :_is_archive_RETURN )
set "attr=%~a2"
set "attr_bit=%attr:~2,1%"
if /i "%attr_bit%"=="a" (set "_RETval=1")
:_is_archive_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_dir ( ref_RETURN PATH )
:$is_dir ( ref_RETURN PATH )
:_is_dir ( ref_RETURN PATH )
:: RETURN == (BOOLEAN as undef/1) whether PATH is a directory
:: NOTE: ref: http://stackoverflow.com/a/3728742/43774 from http://stackoverflow.com/questions/138981/how-do-i-test-if-a-file-is-a-directory-in-a-batch-script
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_dir"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: TCC can't handle nonexistent PATHs (especially non-existent drives)
if NOT EXIST "%~2" ( goto :_is_dir_RETURN )
set "attr=%~a2"
set "attr_bit=%attr:~0,1%"
if /i "%attr_bit%"=="d" (set "_RETval=1")
:_is_dir_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_file ( ref_RETURN PATH )
:$is_file ( ref_RETURN PATH )
:_is_file ( ref_RETURN PATH )
:: RETURN == (BOOLEAN as undef/1) whether PATH is a directory
:: NOTE: ref: http://stackoverflow.com/a/3728742/43774 from http://stackoverflow.com/questions/138981/how-do-i-test-if-a-file-is-a-directory-in-a-batch-script
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_file"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: TCC can't handle nonexistent PATHs (especially non-existent drives)
if NOT EXIST "%~2" ( goto :_is_file_RETURN )
set "attr=%~a2"
set "attr_bit=%attr:~0,1%"
if /i "%attr_bit%"=="-" (set "_RETval=1")
:_is_file_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_hidden ( ref_RETURN PATH )
:$is_hidden ( ref_RETURN PATH )
:_is_hidden ( ref_RETURN PATH )
:: RETURN == (BOOLEAN as undef/1) whether PATH is hidden
:: NOTE: ref: http://stackoverflow.com/a/3728742/43774 from http://stackoverflow.com/questions/138981/how-do-i-test-if-a-file-is-a-directory-in-a-batch-script
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_hidden"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: TCC can't handle nonexistent PATHs (especially non-existent drives)
if NOT EXIST "%~2" ( goto :_is_hidden_RETURN )
set "attr=%~a2"
set "attr_bit=%attr:~3,1%"
if /i "%attr_bit%"=="h" (set "_RETval=1")
:_is_hidden_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_readonly ( ref_RETURN PATH )
:$is_readonly ( ref_RETURN PATH )
:_is_readonly ( ref_RETURN PATH )
:: RETURN == (BOOLEAN as undef/1) whether PATH is readonly (locked)
:: NOTE: ref: http://stackoverflow.com/a/3728742/43774 from http://stackoverflow.com/questions/138981/how-do-i-test-if-a-file-is-a-directory-in-a-batch-script
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_readonly"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: TCC can't handle nonexistent PATHs (especially non-existent drives)
if NOT EXIST "%~2" ( goto :_is_readonly_RETURN )
set "attr=%~a2"
set "attr_bit=%attr:~1,1%"
if /i "%attr_bit%"=="r" (set "_RETval=1")
:_is_readonly_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_system ( ref_RETURN PATH )
:$is_system ( ref_RETURN PATH )
:_is_system ( ref_RETURN PATH )
:: RETURN == (BOOLEAN as undef/1) whether PATH is a directory
:: NOTE: ref: http://stackoverflow.com/a/3728742/43774 from http://stackoverflow.com/questions/138981/how-do-i-test-if-a-file-is-a-directory-in-a-batch-script
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_is_system"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETval="
set "_RETvar=%~1"
:: TCC can't handle nonexistent PATHs (especially non-existent drives)
if NOT EXIST "%~2" ( goto :_is_system_RETURN )
set "attr=%~a2"
set "attr_bit=%attr:~4,1%"
if /i "%attr_bit%"=="s" (set "_RETval=1")
:_is_system_RETURN
REM call :_echo_DEBUG_KEY _RETvar="%_RETvar%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
::( endLocal
::  ( if "%_RETvar%" NEQ "" ( if NOT 01 == 1.0 (
::      set "%_RETvar%=%_RETval%"
::      ) else (
::      set %_RETvar=%_RETval
::      ))
::call :_echo_item_DEBUG_KEY "%__DEBUG%" "%__DEBUG_KEY%" "%__ME%" "%__MEfn%" "[ %__MEfn% :: done ]"
::)
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_link ( ref_RETURN PATH )
:$is_link ( ref_RETURN PATH )
:_is_link ( ref_RETURN PATH )
:: RETURN == (BOOLEAN as undef/1) whether PATH is a link (symbolic link, includes junctions)
:: NOTE: TCC attribute expansion is bugged, and doesn't display the link attribute correctly
setLocal
set "_RETval="
set "_RETvar=%~1"
if NOT EXIST "%~2" ( goto :_is_link_RETURN )
set "attr=%~a2"
set "attr_bit=%attr:~-1,1%"
:: NOTE: TCC ~aN is no longer compatible with CMD (does not show the link attribute)
if NOT 01 == 1.0 ( goto :_is_link_TEST )
set "attr_bit=-"
set "attr=%@lower[%@attrib[%~2]]"
if %@wild[%attr%,*l*] == 1 (
    set "attr_bit=l"
    )
:_is_link_TEST
if /i "%attr_bit%"=="l" (set "_RETval=1")
:_is_link_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$is_junction ( ref_RETURN PATH )
:$is_junction ( ref_RETURN PATH )
:_is_junction ( ref_RETURN PATH )
:: RETURN == (BOOLEAN as undef/1) whether PATH is a junction
setLocal
set "_RETval="
set "_RETvar=%~1"
if NOT EXIST "%~2" ( goto :_is_junction_RETURN )
call :_is_link is_link "%~2"
if NOT DEFINED is_link ( goto :_is_junction_RETURN )
set path_basename=%~nx2
set path_abs=%~dpnx2
:: use ...* to avoid searching within a directory (also, works fine for files)
:: only need 1st match
set "DIRCMD=" &:: remove DIRCMD as it could interfere
:: NOTE: TCC dir formats time as 24 hour (HH:mm) vs CMD 12 hour (HH:mm A/PM)
if 01 == 1.0 ( goto :_readsymlink_TCC )
:_is_junction_CMD
FOR /F "tokens=1,2,3,4*" %%G IN ('dir /A:L "%path_abs%*" ^| "%SystemRoot%\system32\findstr.EXE" "<JUNCTION"') DO (
    set "_dir_entry=%%K"
    goto :_is_junction_DIR_DONE
    )
:_is_junction_TCC
FOR /F "tokens=1,2,3*" %%G IN ('dir /A:L "%path_abs%*" ^| "%SystemRoot%\system32\findstr.EXE" "<JUNCTION"') DO (
    set "_dir_entry=%%J"
    goto :_is_junction_DIR_DONE
    )
:_is_junction_DIR_DONE
if NOT DEFINED _dir_entry ( goto :_is_junction_RETURN )
:: find symlink portion and pull it off the entry, then match pathnames
call set symlink=%%_dir_entry:*%path_basename% [=%%
set symlink= [%symlink%
call set path_name=%%_dir_entry:%symlink%=%%
if "%path_basename%" == "%path_name%" ( set _RETval=1 )
:_is_junction_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$readsymlink_of ( ref_RETURN PATH )
:$readsymlink_of ( ref_RETURN PATH )
:_readsymlink_of ( ref_RETURN PATH )
:: RETURN == target path of PATH (in raw, non-fully-qualified / non-canonicalized form); NULL if PATH is not a link/junction
:: NOTE: only follows a single link (if present)
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_readsymlink_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_readsymlink_of_RETURN )
set path_basename=%~nx2
set path_abs=%~dpnx2
call :_is_link is_link "%~2"
REM call :_echo_DEBUG_KEY path_basename="%path_basename%"
if NOT DEFINED is_link ( set "_RETval=" & goto :_readsymlink_of_FOUND )
:: use ...* to avoid searching within a directory (also, works fine for files)
:: the 1st match is correct, take it and stop looking (avoids collisions with similar link names)
:: NOTE: TCC dir formats time as 24 hour (HH:mm) vs CMD 12 hour (HH:mm A/PM)
if 01 == 1.0 ( goto :_readsymlink_TCC )
:_readsymlink_CMD
FOR /F "tokens=1,2,3,4*" %%G IN ('dir /A:L "%path_abs%*" ^| "%SystemRoot%\system32\findstr.EXE" "<SYMLINK <JUNCTION"') DO (
    set "_dir_entry=%%K"
    goto :_readsymlink_of_DIR_DONE
    )
:_readsymlink_TCC
FOR /F "tokens=1,2,3*" %%G IN ('dir /A:L "%path_abs%*" ^| "%SystemRoot%\system32\findstr.EXE" "<SYMLINK <JUNCTION"') DO (
    set "_dir_entry=%%J"
    goto :_readsymlink_of_DIR_DONE
    )
:_readsymlink_of_DIR_DONE
call set _RETval=%%_dir_entry:*%path_basename% [=%%
set _RETval=%_RETval:~0,-1%
:_readsymlink_of_FOUND
:_readsymlink_of_DONE
:_readsymlink_of_RETURN
REM call :_echo_DEBUG_KEY _RETval=%_RETval%
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$readlink_of ( ref_RETURN PATH )
:$readlink_of ( ref_RETURN PATH )
:_readlink_of ( ref_RETURN PATH )
:: RETURN == fully qualified target path of PATH; NULL if PATH is not a link/junction
:: NOTE: only follows a single link (if present)
:: NOTE: using _fq_fullname for full qualification to deal with difficult special cases (and nasty TCC drive/UNC bugs [ref: http://jpsoft.com/forums/threads/using-dp1-for-paths-with-unavailable-drives.3450 @@ http://webcitation.org/63ua1bpOk])
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_readlink_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
if NOT DEFINED _RETval ( goto :_readlink_of_RETURN )
call :_readsymlink_of _RETval "%_RETval%"
if NOT DEFINED _RETval ( goto :_readlink_of_RETURN )
::call :_split_drive_path_of _drive _path "%_RETval%"
::if DEFINED _drive ( goto :_readlink_of_FOUND )
::if NOT "%_path:~0,1%" == "\" ( set "_RETval=%~dp2%_path%" )
:_readlink_of_FOUND
call :_FQ_fullname_of _RETval "%_RETval%"
:_readlink_of_DONE
:_readlink_of_RETURN
REM call :_echo_DEBUG_KEY _RETval=%_RETval%
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$realpath_of ( ref_RETURN PATH [MAX_DEPTH] )
:$realpath_of ( ref_RETURN PATH [MAX_DEPTH] )
:_realpath_of ( ref_RETURN PATH [MAX_DEPTH] )
:: RETURN == fully qualified & canonical real/final path of PATH (to MAX_DEPTH level [default=9]; NULL if still not at final, non-link/junction PATH by MAX_DEPTH)
:: NOTE: MAX_DEPTH is used to avoid an infinite loop for circular link references
:: NOTE: similar to "realpath" or "readlink -f"
:: NOTE: ToDO: research changing all parent directories into real paths (for a true canonical real_path); currently, symbolic links in PARENTs are not dereferenced
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=_realpath_of"
REM call :_echo_DEBUG_KEY [ %__MEfn% :: start ]
set "_RETvar=%~1"
set "_RETval=%~2"
set "max_depth=%~3"
if NOT DEFINED max_depth ( set max_depth=9 )
REM call :_echo_DEBUG_KEY _RETvar=%_RETvar%
REM call :_echo_DEBUG_KEY _RETval=%_RETval%
REM call :_echo_DEBUG_KEY max_depth=%max_depth%
:_realpath_of_LOOP
call :_is_link is_link "%_RETval%"
if NOT DEFINED is_link ( goto :_realpath_of_FOUND )
if NOT %max_depth% GTR 0 ( set "_RETval=" & goto :_realpath_of_DONE )
call :_readlink_of _RETval "%_RETval%"
REM call :_echo_DEBUG_KEY _RETval="%_RETval%"
set /a max_depth -= 1
goto :_realpath_of_LOOP
:_realpath_of_FOUND
call :_FQ_fullname_of _RETval "%_RETval%"
:_realpath_of_DONE
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

::
:$$ascii_chr ( ref_RETURN [ ASCII_CODEs ... ] )
:$ascii_chr
:: RETURN == ASCII character corresponding to the provided ASCII code point
:: ASCII_CODE == desired ASCII character code
:: ref: <https://stackoverflow.com/a/49959194/43774> @@ <https://archive.is/zRRJt#29%>
:: ref: <https://www.dostips.com/forum/viewtopic.php?f=3&t=5326&start=105> @@ <https://archive.is/FnTRi>
setLocal
set "__DEBUG_KEY=@"
set "__MEfn=$ascii_chr"
set "_RETval="
set "_RETvar=%~1"
call :$tempfile tempfile "$library"
:_ascii_chr_LOOP
shift
set "ascii_code=%~1"
if NOT DEFINED ascii_code goto :_ascii_chr_DONE
echo|set /p _OUTPUT="" >"%tempfile%" 2>nul
"C:\WINDOWS\System32\makecab.EXE" /d compress=off /d reservePerDataBlockSize=0 /d reservePerFolderSize=%ascii_code% "%tempfile%" "%tempfile%" >nul
<"%tempfile%" ((for /L %%g in (1,1,38) do pause>nul)&set /p "ch=") >nul
set "ch=%ch:~0,1%"
set "_RETval=%_RETval%%ch%"
goto :_ascii_chr_LOOP
:_ascii_chr_DONE
:_ascii_chr_RETURN
endLocal & set %_RETvar%^=%_RETval%
goto :EOF
::

:: end :: FUNCTIONS (library:rev81)
